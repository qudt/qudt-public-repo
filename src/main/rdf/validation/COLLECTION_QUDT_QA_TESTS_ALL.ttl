@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix qudt: <http://qudt.org/schema/qudt/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .

<http://qudt.org/$$QUDT_VERSION$$/collection/qa/all>
  a owl:Ontology ;
  owl:imports <http://qudt.org/$$QUDT_VERSION$$/collection/usertest> ;
  owl:imports <http://qudt.org/$$QUDT_VERSION$$/vocab/constant> ;
  owl:imports <http://qudt.org/$$QUDT_VERSION$$/vocab/soqk> ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  rdfs:label "QUDT Collection - QA TESTS - ALL - v $$QUDT_VERSION$$" ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://purl.org/dc/terms/"^^xsd:anyURI ;
    sh:prefix "dcterms" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://qudt.org/schema/qudt/"^^xsd:anyURI ;
    sh:prefix "qudt" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://qudt.org/vocab/dimensionvector/"^^xsd:anyURI ;
    sh:prefix "qkdv" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://qudt.org/vocab/quantitykind/"^^xsd:anyURI ;
    sh:prefix "quantitykind" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://qudt.org/vocab/unit/"^^xsd:anyURI ;
    sh:prefix "unit" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI ;
    sh:prefix "rdf" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI ;
    sh:prefix "rdfs" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI ;
    sh:prefix "xsd" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI ;
    sh:prefix "owl" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI ;
    sh:prefix "skos" ;
  ] ;
  sh:declare [
    a sh:PrefixDeclaration ;
    sh:namespace "http://www.w3.org/ns/shacl#"^^xsd:anyURI ;
    sh:prefix "sh" ;
  ] .

qudt:ClosedWorldShape
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Ensure that all instances of a class use only the properties defined for that class." ;
    sh:message "Predicate {?p} is not defined for instance {$this}." ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
SELECT $this ?p ?o
WHERE {
$this a/rdfs:subClassOf* qudt:Concept .
FILTER NOT EXISTS {$this qudt:deprecated true}
$this ?p ?o .
FILTER(STRSTARTS (str(?p), 'http://qudt.org/schema/qudt'))
FILTER NOT EXISTS {$this a sh:NodeShape}
FILTER NOT EXISTS {$this a/rdfs:subClassOf* ?class .
\t\t\t?class sh:property/sh:path ?p .
}
FILTER NOT EXISTS {$this a/rdfs:subClassOf* ?class .
?class sh:xone/rdf:rest*/rdf:first/sh:property/sh:path ?p .
}
FILTER NOT EXISTS {$this a/rdfs:subClassOf* ?class .
?class sh:or/rdf:rest*/rdf:first/sh:property/sh:path ?p .
}
}
""" ;
  ] ;
  sh:targetClass qudt:Concept .

qudt:CurencyNumberShape
  a sh:NodeShape ;
  sh:property [
    sh:datatype xsd:string ;
    sh:maxCount 1 ;
    sh:message "qudt:currencyNumber must have a string-typed value that contains exactly three digits." ;
    sh:minCount 1 ;
    sh:path qudt:currencyNumber ;
    sh:pattern "^\\d{3}$" ;
  ] ;
  sh:targetSubjectsOf qudt:currencyNumber .

qudt:DefinedByConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  rdfs:label "Target class must be have a rdfs:isDefinedBy property" ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Target class must be have a rdfs:isDefinedBy property" ;
    sh:message "Resource '{$this}' lacks an rdfs:isDefinedBy property." ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """SELECT $this
WHERE {
FILTER NOT EXISTS {$this rdfs:isDefinedBy ?y}
FILTER NOT EXISTS {$this qudt:deprecated true}
}""" ;
  ] ;
  sh:targetClass qudt:PhysicalConstant ;
  sh:targetClass qudt:Prefix ;
  sh:targetClass qudt:QuantityKind ;
  sh:targetClass qudt:QuantityKindDimensionVector ;
  sh:targetClass qudt:SystemOfQuantityKinds ;
  sh:targetClass qudt:SystemOfUnits ;
  sh:targetClass qudt:Unit .

qudt:DeprecatedConceptInfoShape
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/usertest> ;
  rdfs:label "Informs about presence of a deprecated QUDT resource" ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Informs if a deprecated QUDT resource is present" ;
    sh:message "Deprecated resource '{?this}' is present, which will be removed in the next major version of QUDT {?replacementMessage}" ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/usertest> ;
    sh:select """
    SELECT ?s $this ?replacementMessage
    WHERE {
        $this qudt:deprecated true .
        OPTIONAL {
            $this dcterms:isReplacedBy ?replacement .
        }
        BIND(IF(
                BOUND(?replacement),
                CONCAT("as it has been replaced by ", STR(?replacement)),
                "without replacement.")
            AS ?replacementMessage)
    }
    """ ;
  ] ;
  sh:targetClass qudt:Concept .

qudt:DeprecatedPropertyInfoShape
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/usertest> ;
  rdfs:label "Info about presence of a deprecated QUDT property" ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Informs if a deprecated QUDT property is present" ;
    sh:message "Deprecated property '{?this}' is present, which will be removed in the next major version of QUDT {?replacementMessage}" ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/usertest> ;
    sh:select """
    SELECT ?s ?this ?replacementMessage
        WHERE {
        ?this qudt:deprecated true .
        OPTIONAL {
            $this dcterms:isReplacedBy ?replacement .
        }
        BIND(IF(
            BOUND(?replacement),
            CONCAT("as it has been replaced by ", STR(?replacement)),
            "without replacement")
        AS ?replacementMessage)
    }""" ;
  ] ;
  sh:targetClass rdf:Property .

qudt:ExactMatchGoesBothWaysConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Ensure that if A qudt:exactMatch B then B qudt:exactMatch A" ;
    sh:message "Missing triple: {$t} qudt:exactMatch {$this} ." ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
SELECT $this ?t
WHERE {
$this qudt:exactMatch ?t .
FILTER NOT EXISTS {$this qudt:deprecated true} .
FILTER NOT EXISTS {?t qudt:exactMatch $this } .
}
""" ;
  ] ;
  sh:targetClass qudt:Concept .

qudt:InconsistentDimensionVectorInSKOSHierarchyConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Checks that a QuantityKind has the same dimension vector as any skos:broader QuantityKind" ;
    sh:message "Unit {$this} has dimension vector {$udv} which is not the same as the dimension vector of its skos:broader, {$qk} with dimension vector {$qdv}" ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
SELECT $this ?udv ?qk ?qdv
WHERE {
FILTER NOT EXISTS {$this qudt:deprecated true} .
$this qudt:hasDimensionVector  ?udv .
$this skos:broader* ?qk .
?qk qudt:hasDimensionVector ?qdv .
FILTER (?udv != ?qdv) .
}
""" ;
  ] ;
  sh:targetClass qudt:QuantityKind .

qudt:InconsistentUnitAndDimensionVectorConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Checks that a Unit and its QuantityKind have the same dimension vector" ;
    sh:message "Unit {$this} has dimension vector {$udv} which is not the same as the dimension vector of its quantity kind {$qk} with dimension vector {$qdv}" ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
SELECT $this ?udv ?qk ?qdv
WHERE {
FILTER NOT EXISTS {$this qudt:deprecated true} .
$this qudt:hasDimensionVector  ?udv .
$this qudt:hasQuantityKind ?qk .
?qk qudt:hasDimensionVector ?qdv .
FILTER (?udv != qkdv:NotApplicable) .
FILTER (?qdv != qkdv:NotApplicable) .
FILTER (?udv != ?qdv) .
}
""" ;
  ] ;
  sh:targetClass qudt:Unit .

qudt:MultipleDescriptionsConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  rdfs:label "Warning about use of multiple descriptions with the same language tag" ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Ensures each qudt:Concept instance doesn't have multiple dcterms:description values with the same language tag." ;
    sh:message "{$this} has {?count} dcterms:description triples with language tag @{?langTag}." ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this (COUNT(?label) AS ?count) ?langTag
            WHERE {
                FILTER NOT EXISTS {$this qudt:deprecated true} .
                $this dcterms:description ?label .
                FILTER(langMatches(lang(?label), ?langTag))
                BIND(lang(?label) AS ?langTag)
            }
            GROUP BY $this ?langTag
            HAVING(?count > 1)
        """ ;
  ] ;
  sh:targetClass qudt:Concept .

qudt:MultipleLabelsConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  rdfs:label "Warning about use of multiple labels with the same language tag" ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Ensures each qudt:Concept instance doesn't have multiple rdfs:labels with the same language tag." ;
    sh:message "{$this} has {?count} rdfs:label triples with language tag @{?langTag}." ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this (COUNT(?label) AS ?count) ?langTag
            WHERE {
                FILTER NOT EXISTS {$this qudt:deprecated true} .
                $this rdfs:label ?label .
                FILTER(langMatches(lang(?label), ?langTag))
                BIND(lang(?label) AS ?langTag)
            }
            GROUP BY $this ?langTag
            HAVING(?count > 1)
        """ ;
  ] ;
  sh:targetClass qudt:Concept .

qudt:QuantityKindShape
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:property [
    rdfs:comment "Check for inconsistent qudt:exactMatch vs skos:broader triples" ;
    sh:path qudt:exactMatch ;
    sh:sparql [
      a sh:SPARQLConstraint ;
      sh:message "{$this} is skos:broader and qudt:exactMatch with {?qk}." ;
      sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
      sh:select """
                SELECT DISTINCT $this ?qk
                WHERE {
                FILTER NOT EXISTS {$this qudt:deprecated true} .
                $this
                    skos:broader ?qk ;
                    qudt:exactMatch ?qk .
                }
              """ ;
    ] ;
  ] ;
  sh:property [
    rdfs:comment "Check for inconsistent dimensionvectors in the skos:broader hierarchy" ;
    sh:path qudt:hasDimensionVector ;
    sh:sparql [
      a sh:SPARQLConstraint ;
      sh:message "{$this} has a dimension vector that is inconsistent with {?qk} in its skos:broader hierarchy." ;
      sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
      sh:select """
                SELECT $this ?qk
                WHERE {
                FILTER NOT EXISTS {$this qudt:deprecated true} .
                $this qudt:hasDimensionVector  ?udv .
                $this skos:broader* ?qk .
                ?qk qudt:hasDimensionVector ?qdv .
                FILTER (?udv != ?qdv) .
                }
          """ ;
    ] ;
  ] ;
  sh:targetClass qudt:QuantityKind .

qudt:UniqueSymbolTypeRestrictedPropertyConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  rdfs:label "Unique symbol type restricted property constraint" ;
  sh:deactivated true ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Checks that a resource has a unique symbol within its type hierarchy below qudt:Concept" ;
    sh:message "Resource, '{$this}' of type '{?myType}', has non-unique symbol, '{?symbol}', that conflicts with '{?another}' of type '{?anotherType}'" ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """SELECT DISTINCT $this ?symbol ?another ?myType ?anotherType
WHERE {{
\t$this qudt:symbol ?symbol .
     ?another qudt:symbol ?symbol .
    FILTER (?another != $this)
   }
   FILTER NOT EXISTS {$this qudt:deprecated true} .
    $this a ?myType .
    ?myType <http://www.w3.org/2000/01/rdf-schema#subClassOf>+ qudt:Concept .
    ?another a ?anotherType .
    ?anotherType <http://www.w3.org/2000/01/rdf-schema#subClassOf>+ qudt:Concept .
   FILTER (?myType = ?anotherType)
}""" ;
  ] ;
  sh:targetClass qudt:Unit .

qudt:UnitPointsToAllExactMatchQuantityKindsConstraint
  a sh:NodeShape ;
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:severity sh:Info ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    rdfs:comment "Ensure that if a Unit hasQuantityKind A, and A qudt:exactMatch B, then the Unit hasQuantityKind B " ;
    sh:message "Missing triple: {$this} qudt:hasQuantityKind {?qk2}, because {?qk} qudt:exactMatch {?qk2}" ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
SELECT $this ?qk ?qk2
WHERE {
FILTER NOT EXISTS {$this qudt:deprecated true} .
$this qudt:hasQuantityKind ?qk .
?qk qudt:exactMatch ?qk2 .
FILTER NOT EXISTS {$this qudt:hasQuantityKind ?qk2}
}
""" ;
  ] ;
  sh:targetClass qudt:Unit .

qudt:UnitShape
  rdfs:isDefinedBy <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
  sh:property [
    rdfs:comment "Check for inconsistent dimensionvectors from units and quantitykinds" ;
    sh:path qudt:hasDimensionVector ;
    sh:sparql [
      a sh:SPARQLConstraint ;
      sh:message "{$this} has a dimension vector that is inconsistent with its quantity kind, {?qk}" ;
      sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
      sh:select """
SELECT $this ?qk
WHERE {
FILTER NOT EXISTS {$this qudt:deprecated true} .
$this qudt:hasDimensionVector  ?udv .
$this qudt:hasQuantityKind ?qk .
FILTER (?qk != quantitykind:Unknown) .
?qk qudt:hasDimensionVector ?qdv .
FILTER (?udv != ?qdv) .
}
""" ;
    ] ;
  ] ;
  sh:targetClass qudt:Unit .

qudt:conversionMultiplierSnShape
  rdfs:comment "qudt:conversionMultiplier must match qudt:conversionMultiplierSN if present" ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "{$this} qudt:conversionMultiplier is {?valueDecimalNoTrailingZeros}, which does not match the value of qudt:conversionMultiplierSN, {?valueSN}, converted to decimal notation, {?valueSNStringValue} .  " ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this ?valueDecimal ?valueDecimalNoTrailingZeros ?valueSN ?m ?e ?exponent ?mNoDot ?mDigitCount ?valueSNStringValue ?onePos ?lastMantissaDigit ?leftStart ?leftEnd ?rightStart ?rightEnd ?result
                        WHERE {
                        FILTER NOT EXISTS {$this qudt:deprecated true} .
                            # select both values
                            $this
                                qudt:conversionMultiplier ?valueDecimal ;
                                qudt:conversionMultiplierSN ?valueSN .
                            BIND(REPLACE(STR(?valueDecimal), "(\\\\.\\\\d)(\\\\d*[1-9])?0*$", "$1$2") as ?valueDecimalNoTrailingZeros)      # remove trailing zeros from valueDecimal (string)
                            BIND(REPLACE(STR(?valueSN), "[eE]-?\\\\d+$", "") as ?m)                                           # extract the mantissa (string)
                            BIND(REPLACE(STR(?valueSN), "^\\\\d(\\\\.\\\\d+)?[eE]", "") as ?e)                                    # extract the exponent (string)
                            BIND(REPLACE(STR(?m),"(\\\\.|0+$)","") AS ?mNoDot)                                                # remove the comma and trailing zeros from the mantissa
                            BIND(STRLEN(?mNoDot) as ?mDigitCount)                                                           # count the mantissa's characters
                            BIND(xsd:integer(?e) as  ?exponent)                                                             # cast e to an integer, called exponent
                            # prepare a string with 200 zeros padding left and right, mantissa in the middle
                            BIND(CONCAT(
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                                                ?mNoDot,
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") as ?baseStr)
                            # first char has index 1 !!!
                            BIND(201 + ?exponent as ?onePos)
                            BIND(200 + ?mDigitCount  as ?lastMantissaDigit)
                            BIND(IF(?onePos > 201, 201, ?onePos) as ?leftStart)
                            BIND(?onePos+1 as ?leftEnd)
                            BIND(?onePos+1 as ?rightStart)
                            BIND(IF(?lastMantissaDigit+1 > ?onePos+2, ?lastMantissaDigit+1, ?onePos+2)  as ?rightEnd)
                            # determine the expected string
                            BIND(CONCAT(SUBSTR(?baseStr, ?leftStart, ?leftEnd-?leftStart), ".", SUBSTR(?baseStr, ?rightStart, ?rightEnd - ?rightStart)) as  ?valueSNStringValue)
                            # compare with actual decimal value
                            BIND(IF(?valueSNStringValue = STR(?valueDecimalNoTrailingZeros), "match!", "no match!") as ?result)
                            # only generate message if no match (useful during development)
                            FILTER(?result != "match!")
                        }
        """ ;
  ] ;
  sh:targetClass qudt:Unit .

qudt:conversionOffsetSnShape
  rdfs:comment "qudt:conversionOffset must match qudt:conversionOffsetSN if present" ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "{$this} qudt:conversionOffset is {?valueDecimalNoTrailingZeros}, which does not match the value of qudt:conversionOffsetSN, {?valueSN}, converted to decimal notation, {?valueSNStringValue} .  " ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this ?valueDecimal ?valueDecimalNoTrailingZeros ?valueSN ?m ?e ?exponent ?mNoDot ?mDigitCount ?valueSNStringValue ?onePos ?lastMantissaDigit ?leftStart ?leftEnd ?rightStart ?rightEnd ?result
                        WHERE {
                        FILTER NOT EXISTS {$this qudt:deprecated true} .
                            # select both values
                            $this
                                qudt:conversionOffset ?valueDecimal ;
                                qudt:conversionOffsetSN ?valueSN .
                            BIND(REPLACE(STR(?valueDecimal), "(\\\\.\\\\d)(\\\\d*[1-9])?0*$", "$1$2") as ?valueDecimalNoTrailingZeros)      # remove trailing zeros from valueDecimal (string)
                            BIND(REPLACE(STR(?valueSN), "[eE]-?\\\\d+$", "") as ?m)                                           # extract the mantissa (string)
                            BIND(REPLACE(STR(?valueSN), "^\\\\d(\\\\.\\\\d+)?[eE]", "") as ?e)                                    # extract the exponent (string)
                            BIND(REPLACE(STR(?m),"(\\\\.|0+$)","") AS ?mNoDot)                                                # remove the comma and trailing zeros from the mantissa
                            BIND(STRLEN(?mNoDot) as ?mDigitCount)                                                           # count the mantissa's characters
                            BIND(xsd:integer(?e) as  ?exponent)                                                             # cast e to an integer, called exponent
                            # prepare a string with 200 zeros padding left and right, mantissa in the middle
                            BIND(CONCAT(
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                                                ?mNoDot,
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") as ?baseStr)
                            # first char has index 1 !!!
                            BIND(201 + ?exponent as ?onePos)
                            BIND(200 + ?mDigitCount  as ?lastMantissaDigit)
                            BIND(IF(?onePos > 201, 201, ?onePos) as ?leftStart)
                            BIND(?onePos+1 as ?leftEnd)
                            BIND(?onePos+1 as ?rightStart)
                            BIND(IF(?lastMantissaDigit+1 > ?onePos+2, ?lastMantissaDigit+1, ?onePos+2)  as ?rightEnd)
                            # determine the expected string
                            BIND(CONCAT(SUBSTR(?baseStr, ?leftStart, ?leftEnd-?leftStart), ".", SUBSTR(?baseStr, ?rightStart, ?rightEnd - ?rightStart)) as  ?valueSNStringValue)
                            # compare with actual decimal value
                            BIND(IF(?valueSNStringValue = STR(?valueDecimalNoTrailingZeros), "match!", "no match!") as ?result)
                            # only generate message if no match (useful during development)
                            FILTER(?result != "match!")
                        }
        """ ;
  ] ;
  sh:targetClass qudt:Unit .

qudt:prefixMultiplierSnShape
  rdfs:comment "qudt:prefixMultiplier must match qudt:prefixMultiplierSN if present" ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "{$this} qudt:prefixMultiplier is {?valueDecimalNoTrailingZeros}, which does not match the value of qudt:prefixMultiplierSN, {?valueSN}, converted to decimal notation, {?valueSNStringValue} .  " ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this ?valueDecimal ?valueDecimalNoTrailingZeros ?valueSN ?m ?e ?exponent ?mNoDot ?mDigitCount ?valueSNStringValue ?onePos ?lastMantissaDigit ?leftStart ?leftEnd ?rightStart ?rightEnd ?result
                        WHERE {
                        FILTER NOT EXISTS {$this qudt:deprecated true} .
                            # select both values
                            $this
                                qudt:prefixMultiplier ?valueDecimal ;
                                qudt:prefixMultiplierSN ?valueSN .
                            BIND(REPLACE(STR(?valueDecimal), "(\\\\.\\\\d)(\\\\d*[1-9])?0*$", "$1$2") as ?valueDecimalNoTrailingZeros)      # remove trailing zeros from valueDecimal (string)
                            BIND(REPLACE(STR(?valueSN), "[eE]-?\\\\d+$", "") as ?m)                                           # extract the mantissa (string)
                            BIND(REPLACE(STR(?valueSN), "^\\\\d(\\\\.\\\\d+)?[eE]", "") as ?e)                                    # extract the exponent (string)
                            BIND(REPLACE(STR(?m),"(\\\\.|0+$)","") AS ?mNoDot)                                                # remove the comma and trailing zeros from the mantissa
                            BIND(STRLEN(?mNoDot) as ?mDigitCount)                                                           # count the mantissa's characters
                            BIND(xsd:integer(?e) as  ?exponent)                                                             # cast e to an integer, called exponent
                            # prepare a string with 200 zeros padding left and right, mantissa in the middle
                            BIND(CONCAT(
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                                                ?mNoDot,
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") as ?baseStr)
                            # first char has index 1 !!!
                            BIND(201 + ?exponent as ?onePos)
                            BIND(200 + ?mDigitCount  as ?lastMantissaDigit)
                            BIND(IF(?onePos > 201, 201, ?onePos) as ?leftStart)
                            BIND(?onePos+1 as ?leftEnd)
                            BIND(?onePos+1 as ?rightStart)
                            BIND(IF(?lastMantissaDigit+1 > ?onePos+2, ?lastMantissaDigit+1, ?onePos+2)  as ?rightEnd)
                            # determine the expected string
                            BIND(CONCAT(SUBSTR(?baseStr, ?leftStart, ?leftEnd-?leftStart), ".", SUBSTR(?baseStr, ?rightStart, ?rightEnd - ?rightStart)) as  ?valueSNStringValue)
                            # compare with actual decimal value
                            BIND(IF(?valueSNStringValue = STR(?valueDecimalNoTrailingZeros), "match!", "no match!") as ?result)
                            # only generate message if no match (useful during development)
                            FILTER(?result != "match!")
                        }
        """ ;
  ] ;
  sh:targetClass qudt:Prefix .

qudt:standardUncertaintySnShape
  rdfs:comment "qudt:standardUncertainty must match qudt:standardUncertaintySN if present" ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "{$this} qudt:standardUncertainty is {?valueDecimalNoTrailingZeros}, which does not match the value of qudt:standardUncertaintySN, {?valueSN}, converted to decimal notation, {?valueSNStringValue} .  " ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this ?valueDecimal ?valueDecimalNoTrailingZeros ?valueSN ?m ?e ?exponent ?mNoDot ?mDigitCount ?valueSNStringValue ?onePos ?lastMantissaDigit ?leftStart ?leftEnd ?rightStart ?rightEnd ?result
                        WHERE {
                        FILTER NOT EXISTS {$this qudt:deprecated true} .
                            # select both values
                            $this
                                qudt:standardUncertainty ?valueDecimal ;
                                qudt:standardUncertaintySN ?valueSN .
                            BIND(REPLACE(STR(?valueDecimal), "(\\\\.\\\\d)(\\\\d*[1-9])?0*$", "$1$2") as ?valueDecimalNoTrailingZeros)      # remove trailing zeros from valueDecimal (string)
                            BIND(REPLACE(STR(?valueSN), "[eE]-?\\\\d+$", "") as ?m)                                           # extract the mantissa (string)
                            BIND(REPLACE(STR(?valueSN), "^\\\\d(\\\\.\\\\d+)?[eE]", "") as ?e)                                    # extract the exponent (string)
                            BIND(REPLACE(STR(?m),"(\\\\.|0+$)","") AS ?mNoDot)                                                # remove the comma and trailing zeros from the mantissa
                            BIND(STRLEN(?mNoDot) as ?mDigitCount)                                                           # count the mantissa's characters
                            BIND(xsd:integer(?e) as  ?exponent)                                                             # cast e to an integer, called exponent
                            # prepare a string with 200 zeros padding left and right, mantissa in the middle
                            BIND(CONCAT(
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                                                ?mNoDot,
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") as ?baseStr)
                            # first char has index 1 !!!
                            BIND(201 + ?exponent as ?onePos)
                            BIND(200 + ?mDigitCount  as ?lastMantissaDigit)
                            BIND(IF(?onePos > 201, 201, ?onePos) as ?leftStart)
                            BIND(?onePos+1 as ?leftEnd)
                            BIND(?onePos+1 as ?rightStart)
                            BIND(IF(?lastMantissaDigit+1 > ?onePos+2, ?lastMantissaDigit+1, ?onePos+2)  as ?rightEnd)
                            # determine the expected string
                            BIND(CONCAT(SUBSTR(?baseStr, ?leftStart, ?leftEnd-?leftStart), ".", SUBSTR(?baseStr, ?rightStart, ?rightEnd - ?rightStart)) as  ?valueSNStringValue)
                            # compare with actual decimal value
                            BIND(IF(?valueSNStringValue = STR(?valueDecimalNoTrailingZeros), "match!", "no match!") as ?result)
                            # only generate message if no match (useful during development)
                            FILTER(?result != "match!")
                        }
        """ ;
  ] ;
  sh:targetClass qudt:ConstantValue .

qudt:valueSnShape
  rdfs:comment "qudt:value must match qudt:valueSN if present" ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "{$this} qudt:value is {?valueDecimalNoTrailingZeros}, which does not match the value of qudt:valueSN, {?valueSN}, converted to decimal notation, {?valueSNStringValue} .  " ;
    sh:prefixes <http://qudt.org/$$QUDT_VERSION$$/collection/qa/all> ;
    sh:select """
            SELECT $this ?valueDecimal ?valueDecimalNoTrailingZeros ?valueSN ?m ?e ?exponent ?mNoDot ?mDigitCount ?valueSNStringValue ?onePos ?lastMantissaDigit ?leftStart ?leftEnd ?rightStart ?rightEnd ?result
                        WHERE {
                        FILTER NOT EXISTS {$this qudt:deprecated true} .
                            # select both values
                            $this
                                qudt:value ?valueDecimal ;
                                qudt:valueSN ?valueSN .
                            BIND(REPLACE(STR(?valueDecimal), "(\\\\.\\\\d)(\\\\d*[1-9])?0*$", "$1$2") as ?valueDecimalNoTrailingZeros)     # remove trailing zeros from valueDecimal (string)
                            BIND(REPLACE(STR(?valueSN), "[eE]-?\\\\d+$", "") as ?m)                                           # extract the mantissa (string)
                            BIND(REPLACE(STR(?valueSN), "^\\\\d(\\\\.\\\\d+)?[eE]", "") as ?e)                                    # extract the exponent (string)
                            BIND(REPLACE(STR(?m),"(\\\\.|0+$)","") AS ?mNoDot)                                                # remove the comma and trailing zeros from the mantissa
                            BIND(STRLEN(?mNoDot) as ?mDigitCount)                                                           # count the mantissa's characters
                            BIND(xsd:integer(?e) as  ?exponent)                                                             # cast e to an integer, called exponent
                            # prepare a string with 200 zeros padding left and right, mantissa in the middle
                            BIND(CONCAT(
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                                                ?mNoDot,
                                                "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") as ?baseStr)
                            # first char has index 1 !!!
                            BIND(201 + ?exponent as ?onePos)
                            BIND(200 + ?mDigitCount  as ?lastMantissaDigit)
                            BIND(IF(?onePos > 201, 201, ?onePos) as ?leftStart)
                            BIND(?onePos+1 as ?leftEnd)
                            BIND(?onePos+1 as ?rightStart)
                            BIND(IF(?lastMantissaDigit+1 > ?onePos+2, ?lastMantissaDigit+1, ?onePos+2)  as ?rightEnd)
                            # determine the expected string
                            BIND(CONCAT(SUBSTR(?baseStr, ?leftStart, ?leftEnd-?leftStart), ".", SUBSTR(?baseStr, ?rightStart, ?rightEnd - ?rightStart)) as  ?valueSNStringValue)
                            # compare with actual decimal value
                            BIND(IF(?valueSNStringValue = STR(?valueDecimalNoTrailingZeros), "match!", "no match!") as ?result)
                            # only generate message if no match (useful during development)
                            FILTER(?result != "match!")
                        }
        """ ;
  ] ;
  sh:targetClass qudt:ConstantValue .


