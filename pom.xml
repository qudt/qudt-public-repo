<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.qudt</groupId>
    <artifactId>qudt-public-repo</artifactId>
    <version>3.1.4-SNAPSHOT</version>
    <packaging>pom</packaging>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <qudtPrevReleaseYear>TODO-set-property-qudtPrevReleaseYear</qudtPrevReleaseYear>
        <qudtPrevReleaseMonth>TODO-set-property-qudtPrevReleaseMonth</qudtPrevReleaseMonth>
        <shacl.severity.log>Violation</shacl.severity.log>
    </properties>
    <scm>
        <connection>scm:git:https://github.com/qudt/qudt-public-repo.git</connection>
        <developerConnection>scm:git:https://github.com/qudt/qudt-public-repo.git</developerConnection>
        <url>https://github.com/qudt/qudt-public-repo/tree/master</url>
      <tag>HEAD</tag>
  </scm>
    <build>
        <!--
            project is built using

            mvn install

            the release zip is built using

            mvn -Pzip install
        -->
        <pluginManagement>
            <plugins>
                <plugin>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>3.3.1</version>
                </plugin>
            </plugins>
        </pluginManagement>
        <plugins>
            <!--
                this section defines the actions taken during the build.
                The build is executed as a series of 'lifecycle phases': https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html)
                Each plugin has an <execution> section that binds its execution to a lifecycle phase (or it has a default lifecycle phase in which it runs, or 'none' for direct invocation).
                Here are the phases and the execution ids that are linked to them (executed in the order they appear in this file):
                      validate                 defineAdditionalProperties, preprocess-shacl-files
                      initialize
                      generate-sources         unit-test
                      process-sources          check-src-format, shacl-validate-src
                      generate-resources       copy-rdf-to-dist, copy-rdf-to-work, copy-docs, copy-root-files, validate-shacl-files
                      process-resources
                      process-classes          main
                      generate-test-sources
                      process-test-sources     all-in-one
                      generate-test-resources
                      process-test-resources
                      test-compile
                      process-test-classes     format-dist
                      test                     validate-dist
                      prepare-package
                      package
                      pre-integration-test
                      integration-test
                      post-integration-test
                      verify
                      install                  [Profile -Pzip: release-zip]
                      deploy

                Executions with phase 'none' (invocable directly via command line, not bound to lifecycle):
                      none                     rdfio:pipeline@fix-src       replaces certain triples in src if they are dfferent in target
                                               rdfio:pipeline@inspect       runs a number of interesting queries, mostly on target
                                               spotless:apply@reformat-src  reformats the sources (not target)

            -->

            <plugin>
                <groupId>org.codehaus.gmavenplus</groupId>
                <artifactId>gmavenplus-plugin</artifactId>
                <version>4.1.1</version>
                <executions>
                <!-- Ported execution: defineAdditionalProperties -->
                <execution>
                    <id>defineAdditionalProperties</id>
                    <phase>validate</phase>
                    <goals>
                        <goal>execute</goal>
                    </goals>
                    <configuration>
                        <scripts>
                            <script><![CDATA[
                                    import java.time.OffsetDateTime
                                    import java.time.format.DateTimeFormatter
                                    import java.time.temporal.ChronoField

                                    def majorMinorVersion = "${project.version}".replaceAll('^(\\w+\\.\\w+).*\$', '\$1')
                                    project.properties.setProperty('project.version.majorminor', majorMinorVersion)
                                    project.properties.setProperty('qudt.versioned.iri.prefix', "http://qudt.org/${majorMinorVersion}/")
                                    def now = OffsetDateTime.now().with(ChronoField.MILLI_OF_SECOND, 0)
                                    project.properties.setProperty('qudt.build.date', "${now}")
                                    def currentMonth = now.format(DateTimeFormatter.ofPattern("MM"))
                                    def currentYear = now.format(DateTimeFormatter.ofPattern("YYYY"))
                                    project.properties.setProperty('qudt.current.month', currentMonth)
                                    project.properties.setProperty('qudt.current.year', currentYear)
                                ]]></script>
                        </scripts>
                    </configuration>
                </execution>
                <!-- New execution: preprocess-shacl-files -->
                <execution>
                    <id>preprocess-shacl-files</id>
                    <phase>validate</phase>
                    <goals>
                        <goal>execute</goal>
                    </goals>
                    <configuration>
                        <scripts>
                            <script><![CDATA[
                                // Define base directories
                                def basedir = project.basedir.toString()
                                def srcgenDir = new File(basedir, "src/build/srcgen")
                                def targetDir = new File(basedir, "target/srcgen")

                                // Validate source directory
                                if (!srcgenDir.exists() || !srcgenDir.isDirectory()) {
                                    throw new Exception("Source generation directory not found: ${srcgenDir}")
                                }

                                // Ensure target directory exists
                                targetDir.mkdirs()

                                // Step 1: Collect all aspect directories and their file status
                                def allAspectDirs = srcgenDir.listFiles().findAll { it.isDirectory() }
                                def validAspectDirs = []
                                // Map to store omitted dirs and missing files
                                def omittedAspectDirsWithReasons = [:]

                                allAspectDirs.each { dir ->
                                    def aspectName = dir.name
                                    def queryFile = new File(dir, "query.rq")
                                    def inferTemplateFile = new File(dir, "infer-template.ttl")
                                    def validateTemplateFile = new File(dir, "validate-template.ttl")

                                    def requiredFiles = [
                                        queryFile: queryFile,
                                        inferTemplateFile: inferTemplateFile,
                                        validateTemplateFile: validateTemplateFile
                                    ]

                                    // Find missing files for this directory
                                    def missingFiles = requiredFiles.findAll { !it.value.exists() }.keySet()

                                    if (missingFiles.isEmpty()) {
                                        // All files present, add to valid list
                                        validAspectDirs << dir // Record missing files } else { omittedAspectDirsWithReasons[dir] = missingFiles
                                         }
                                }

                                // Step 2: Process valid directories
                                validAspectDirs.each { aspectDir ->
                                    def aspectName = aspectDir.name
                                    println "Processing aspect: ${aspectName}"

                                    // Load required files
                                    def queryFile = new File(aspectDir, "query.rq")
                                    def inferTemplateFile = new File(aspectDir, "infer-template.ttl")
                                    def validateTemplateFile = new File(aspectDir, "validate-template.ttl")

                                    // Process query file (e.g., remove prefixes)
                                    def queryText = queryFile.text
                                    def queryWithoutPrefixes = queryText.replaceAll('(?is)^\\s*(PREFIX\\s+[^\\n]*\\n)*\\s*', '')
                                                                .replaceAll('(?is)\\s*$', '')
                                    if (!queryWithoutPrefixes) {
                                        throw new Exception("No query body found in ${queryFile}")
                                    }
                                    queryWithoutPrefixes = queryWithoutPrefixes.replaceAll("\\\\", "\\\\\\\\")

                                    // Create output directory for this aspect
                                    def aspectOutputDir = new File(targetDir, aspectName)
                                    aspectOutputDir.mkdirs()

                                    // Define templates to process
                                    def templates = [
                                        [source: inferTemplateFile, target: "infer.ttl"],
                                        [source: validateTemplateFile, target: "validate.ttl"]
                                    ]

                                    // Generate output files
                                    templates.each { template ->
                                        def content = template.source.text
                                        def outputContent = content.replace('{{QUERY_WITHOUT_PREFIXES}}', queryWithoutPrefixes)
                                        outputContent = outputContent.replace('{{AUTOGENERATED_WARNING_DO_NOT_EDIT}}',
                                            " Auto-generated file - ALL EDITS WILL BE LOST! Edit the '-template.ttl' file instead!")
                                        def outputFile = new File(aspectOutputDir, template.target)
                                        outputFile.text = outputContent
                                        println "Generated: ${outputFile}"
                                    }
                                }

                                // Step 3: Log omitted directories with missing file details
                                if (omittedAspectDirsWithReasons) {
                                    println "The following aspects were omitted due to missing required files:"
                                    // Simplify to file names
                                    omittedAspectDirsWithReasons.each { dir, missingFiles ->
                                        def missingFileNames = missingFiles.collect { it.toString().replaceAll('^.*\\.', '') }
                                        println " - ${dir.name}: Missing ${missingFileNames.join(', ')}"
                                    }
                                } else {
                                    println "All aspects processed successfully; no missing files detected."
                                }
                            ]]>
                                </script>
                            </scripts>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.apache.groovy</groupId>
                        <artifactId>groovy-ant</artifactId>
                        <version>4.0.23</version>
                        <scope>runtime</scope>
                    </dependency>
                </dependencies>
            </plugin>

            <plugin>
                <groupId>io.github.qudtlib</groupId>
                <artifactId>shacl-maven-plugin</artifactId>
                <version>1.0.5</version>
                <executions>

                    <execution>
                        <!--
                        SHACL-validates the union of all ttl files in src/vocab and the No-OWL schema
                        against the union of QA-Tests and No-OWL schema
                        writes the validation report target/validation/validationReportSrc.ttl
                        -->
                        <id>shacl-validate-src</id>
                        <phase>process-sources</phase>
                        <goals>
                            <goal>validate</goal>
                        </goals>
                        <configuration>
                            <validations>
                                <validation>
                                    <message>Validating the QUDT sources</message>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>
                                            src/main/rdf/validation/QUDT_SRC_QA_TESTS.ttl
                                        </include>
                                    </shapes>
                                    <data>
                                        <include>
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            src/main/rdf/vocab/**/*.ttl
                                            src/main/rdf/examples/EXAMPLES_QUDT-DATATYPES.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReportSrc.ttl</outputFile>
                                </validation>
                            </validations>
                        </configuration>
                    </execution>
                    <execution>
                        <!--
                        SHACL-that the SHACL definition conform to SHACL
                        writes the validation report target/validation/validationReportShacl.ttl
                        -->
                        <id>validate-shacl-files</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>validate</goal>
                        </goals>
                        <configuration>
                            <validations>
                                <validation>
                                    <message>Validating QUDT SHACL files</message>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>src/build/validation/SHACL-SHACL.ttl</include>
                                    </shapes>
                                    <data>
                                        <include>
                                            src/main/rdf/validation/COLLECTION_QUDT_QA_TESTS_ALL.ttl
                                            src/main/rdf/validation/COLLECTION_QUDT_USER_TESTS.ttl
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT-DATATYPE_NoOWL.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReportShacl.ttl</outputFile>
                                </validation>
                            </validations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>io.github.qudtlib</groupId>
                <artifactId>rdfio-maven-plugin</artifactId>
                <version>1.5.1</version>
                <executions>
                    <execution>
                        <!--
                        makes one big file in target, after the main pipeline has modified target files
                        -->
                        <id>all-in-one</id>
                        <phase>process-test-sources</phase>
                        <goals>
                            <goal>make</goal>
                        </goals>
                        <configuration>
                            <products>
                                <singleFile>
                                    <input>
                                        <include>
                                            src/build/srcgen/collections/SHACL-Collection.ttl
                                            target/dist/vocab/**/*.ttl
                                            target/dist/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            target/dist/schema/shacl/SCHEMA_QUDT-DATATYPES_NoOWL.ttl
                                            target/dist/validation/COLLECTION_QUDT_USER_TESTS.ttl
                                        </include>
                                    </input>
                                    <filters>
                                        <sparqlUpdate>
                                            <![CDATA[
                                            DELETE {
                                                ?ontology ?p ?o .
                                                ?graphMetadata ?gp ?go
                                            } WHERE {
                                                ?ontology
                                                    a owl:Ontology ;
                                                    ?p ?o .
                                                OPTIONAL {
                                                    ?ontology vaem:hasGraphMetadata ?graphMetadata .
                                                    ?graphMetadata ?gp ?go .
                                                }
                                                FILTER(! REGEX(STR(?ontology), "^.+/shacl/qudt-all$"))
                                            }
                                            ]]>
                                        </sparqlUpdate>
                                    </filters>
                                    <outputFile>target/dist/QUDT-all-in-one-SHACL.ttl</outputFile>
                                </singleFile>
                                <singleFile>
                                    <input>
                                        <include>
                                            src/build/srcgen/collections/OWL-Collection.ttl
                                            target/dist/vocab/**/*.ttl
                                            target/dist/schema/SCHEMA_QUDT.ttl
                                        </include>
                                    </input>
                                    <filters>
                                        <sparqlUpdate>
                                            <![CDATA[
                                            DELETE {
                                                ?ontology ?p ?o .
                                                ?graphMetadata ?gp ?go
                                            } WHERE {
                                                ?ontology
                                                    a owl:Ontology ;
                                                    ?p ?o .
                                                OPTIONAL {
                                                    ?ontology vaem:hasGraphMetadata ?graphMetadata .
                                                    ?graphMetadata ?gp ?go .
                                                }
                                                FILTER(! REGEX(STR(?ontology), "^.+/qudt-all$"))
                                            }
                                            ]]>
                                        </sparqlUpdate>
                                    </filters>
                                    <outputFile>target/dist/QUDT-all-in-one-OWL.ttl</outputFile>
                                </singleFile>
                            </products>
                        </configuration>
                    </execution>
                    <execution>
                        <!--
                            interesting inspections,

                            run with:
                            mvn rdfio:pipeline@inspect

                            writes to target/inspection
                        -->
                        <id>inspect</id>
                        <phase>none</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                            <pipeline>
                                <id>inspect</id>
                                <steps>
                                    <!-- make custom shacl functions available in inference and SPARQL-->
                                    <shaclFunctions>
                                        <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                    </shaclFunctions>
                                    <add>
                                        <!--
                                            this reads each file in target into a graph named 'target:{filename}'
                                        -->
                                        <files>
                                            <include>target/dist/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>dist:vocab:${name}</toGraphsPattern>
                                    </add>
                                    <add>
                                        <files>
                                            <include>src/main/rdf/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>src:vocab:${name}</toGraphsPattern>
                                    </add>
                                    <add>
                                        <files>
                                            <include>target/dist/schema/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>dist:schema:${name}</toGraphsPattern>
                                    </add>
                                    <sparqlQuery>
                                        <sparql>
                                            <![CDATA[
                                                SELECT * WHERE {
                                                    GRAPH <dist:schema:SCHEMA_QUDT_NoOWL.ttl> {
                                                        ?type rdfs:subClassOf+ qudt:Unit
                                                    }
                                                    GRAPH <src:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit a ?type .
                                                        OPTIONAL{
                                                            ?unit qudt:conversionMultiplier ?cm
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:conversionMultiplierSN ?cmSN
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:symbol ?symbol
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:hasDimensionVector ?dv
                                                        }
                                                    }
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        OPTIONAL{
                                                           ?unit qudt:conversionMultiplier ?new_cm
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:conversionMultiplierSN ?new_cmSN
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:symbol ?new_symbol
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:hasDimensionVector ?new_dv
                                                        }
                                                    }
                                                    FILTER(
                                                        COALESCE(?cm,"NOT BOUND") != COALESCE(?new_cm, "NOT BOUND")
                                                        || COALESCE(?cmSN,"NOT BOUND") != COALESCE(?new_cmSN, "NOT BOUND")
                                                        || COALESCE(?symbol,"NOT BOUND") != COALESCE(?new_symbol, "NOT BOUND")
                                                        || COALESCE(?dv,"NOT BOUND") != COALESCE(?new_dv, "NOT BOUND")
                                                    )
                                                }
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/src-dist-diff.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <sparql>
                                            <![CDATA[
                                                SELECT ?unit ?cm ?match ?broader ?deprecated
                                                WHERE {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit a qudt:Unit .
                                                        OPTIONAL {
                                                            ?unit qudt:deprecated ?deprecated .
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:conversionMultiplier ?cm
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:exactMatch ?match
                                                        }
                                                        OPTIONAL {
                                                            ?unit skos:broader ?broader
                                                        }
                                                        FILTER (!BOUND(?cm))
                                                        FILTER NOT EXISTS {
                                                            ?unit a qudt:CurrencyUnit
                                                        }
                                                    }
                                                } ORDER BY ?deprecated ?match ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/units-without-conversionMultiplier.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <message>Show non-base units that are neither scaled nor factored</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT distinct ?unit ?possibleBase ?desc ?dv ?cm where {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            a qudt:Unit ;
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:hasDimensionVector ?dv .

                                                            OPTIONAL {
                                                                ?unit qudt:plainTextDescription ?desc.
                                                            }
                                                            OPTIONAL {
                                                                    ?possibleBase
                                                                        qudt:hasDimensionVector ?dv ;
                                                                        qudt:conversionMultiplier 1.0 .
                                                            }
                                                            OPTIONAL {
                                                                {
                                                                    ?unit qudt:plainTextDescription ?desc .
                                                                } UNION {
                                                                    ?unit  dcterms:description ?desc .
                                                                }
                                                            }
                                                        FILTER (?cm != 1.0 && ?cm != 0.0)
                                                        FILTER NOT EXISTS {
                                                            {
                                                                ?unit qudt:scalingOf ?base .
                                                            } UNION {
                                                                ?unit qudt:hasFactorUnit ?fu .
                                                            } UNION {
                                                                ?unit qudt:deprecated true .
                                                            }
                                                        }
                                                    }
                                                } ORDER BY ?dv ?cm ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalingOf/missing-bases.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <message>Show scaled units, base units and multipliers</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT * where {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:scalingOf ?base .
                                                        ?base
                                                            qudt:conversionMultiplier ?baseCm.
                                                        OPTIONAL {
                                                            ?unit qudt:prefix ?prefix .
                                                        }
                                                    }
                                                } ORDER BY ?baseCm ?prefix ?base ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalingOf/all_scalings-end-of-pipeline.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <message>Show scaled units, base units and multipliers</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT * where {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:scalingOf ?base .
                                                        ?base
                                                            qudt:conversionMultiplier ?baseCm.
                                                        OPTIONAL {
                                                            ?unit qudt:prefix ?prefix .
                                                        }
                                                    }
                                                } ORDER BY ?baseCm ?prefix ?base ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalingOf/all.txt</toFile>
                                    </sparqlQuery>

                                    <sparqlQuery>
                                        <file>src/build/inspection/symbol/symbols-via-factor-units.rq</file>
                                        <toFile>target/inspection/symbol/symbols-via-factor-units.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <file>src/build/inspection/symbol/symbols-via-scaling-of.rq</file>
                                        <toFile>target/inspection/symbol/symbols-via-scaling-of.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <file>src/build/inspection/symbol/symbol.rq</file>
                                        <toFile>target/inspection/symbol/symbol.txt</toFile>
                                    </sparqlQuery>

                                </steps>
                            </pipeline>
                        </configuration>
                    </execution>
                    <execution>
                        <!-- unit tests for SHACL functions -->
                        <id>unit-test</id>
                        <phase>generate-sources</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                        <pipeline>
                            <id>unit-test</id>
                            <steps>
                                <!-- make custom shacl functions available in inference and SPARQL-->
                                <shaclFunctions>
                                    <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                </shaclFunctions>
                                <add>
                                    <!-- for testing, we need units and some factor units -->
                                    <file>src/main/rdf/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl</file>
                                    <file>src/build/inference/factorUnits/predefined-factors-and-scalings.ttl</file>
                                </add>
                                <assert>
                                    <message>Test qfn:exponentSuperscript()</message>
                                    <failureMessage>Unit test failed for qfn:exponentSuperscript()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?value ?absolute ?expectedOutput) {
                                                (0 false "⁰")
                                                (1  false "")
                                                (4  false "⁴")
                                                (-1  false "⁻¹")
                                                (1.0  false "")
                                                (4.0  false "⁴")
                                                (-1.0  false "⁻¹")
                                                (-14.0  false "⁻¹⁴")
                                                (0 true "⁰")
                                                (1  true "")
                                                (4  true "⁴")
                                                (-1  true "")
                                                (1.0  true "")
                                                (4.0  true "⁴")
                                                (-1.0  true "")
                                                (-14.0  true "¹⁴")
                                            }
                                            BIND(STR(qfn:exponentSuperscript(?value, ?absolute)) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:decimalToDouble()</message>
                                    <failureMessage>Unit test failed for qfn:decimalToDouble()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?value ?expectedOutput) {
                                                (0 "0.0E0"    )
                                                (1 "1.0E0")
                                                (-1 "-1.0E0")
                                                (0.0001    "1.0E-4")
                                                (10000     "1.0E4" )
                                            }
                                            BIND(STR(qfn:decimalToDouble(?value)) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test nf:decimal.pow()</message>
                                    <failureMessage>Unit test failed for nf:decimal.pow()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        PREFIX nf: <https://github.com/qudtlib/numericFunctions/>
                                        SELECT *
                                        WHERE {
                                            VALUES (?base ?exp ?expectedOutput) {
                                                (2 0          1)
                                                (0 1          0)
                                                (1 0          1)
                                                (0 0          1)
                                                (4 -1         0.25)
                                                (2 -2         0.25)
                                                (2 -3         0.125)
                                                (3 2          9)
                                                (3 3          27)
                                                (1.2 2       1.44)
                                            }
                                            BIND(nf:decimal.pow(?base, ?exp,34) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test nf:decimal.div()</message>
                                    <failureMessage>Unit test failed for nf:decimal.div()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        PREFIX nf: <https://github.com/qudtlib/numericFunctions/>
                                        SELECT *
                                        WHERE {
                                            VALUES (?value ?divisor ?precision ?expectedOutput) {
                                                (2 2 34 1)
                                                (2 3 34 0.6666666666666666666666666666666667)
                                                (1 4 34 0.25)
                                            }
                                            BIND(nf:decimal.div(?value, ?divisor, ?precision) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:pow()</message>
                                    <failureMessage>Unit test failed for qfn:pow()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                        VALUES (?base ?exp ?expectedOutput) {
                                        (2 0          1)
                                        (0 1          0)
                                        (0 -1         0)
                                        (0 0          1)
                                        (4 -1         0.25)
                                        (2 -2         0.25)
                                        (2 -3         0.125)
                                        (3 2          9)
                                        (3 3          27)
                                        (1.2 2       1.44)
                                        }
                                        BIND(qfn:pow(?base, ?exp) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:decimalPrecision()</message>
                                    <failureMessage>Unit test failed for qfn:decimalPrecision()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                            VALUES (?input ?expectedOutput) {
                                                (0            0)
                                                (0.0          0)
                                                (1            1)
                                                (1.0          1)
                                                (-1           1)
                                                (-1.0         1)
                                                (-.1          1)
                                                (10           1)
                                                (100          1)
                                                (100.001      6)
                                                (100.000      1)
                                                (00123.456000 6)
                                                (-0.00000001  1)
                                            }
                                        BIND(qfn:decimalPrecision(?input) AS ?precision)
                                        FILTER(!BOUND(?precision) || ?precision != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test nf:decimal.roundToPrecision()</message>
                                    <failureMessage>Unit test failed for nf:decimal.roundToPrecision()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        PREFIX nf: <https://github.com/qudtlib/numericFunctions/>
                                        SELECT *
                                        WHERE {
                                            VALUES (?input ?precision ?expectedOutput) {
                                                (0            1         0.0)
                                                (0.0          1         0.0)
                                                (0.1          1         0.1)
                                                (.1           1         0.1)
                                                (1            1         1.0)
                                                (+1           1         1.0)
                                                (+1.0         1         1.0)
                                                (+.0          1         0.0)
                                                (+.1          1         0.1)
                                                (1.0          1         1.0)
                                                (-1           1        -1.0)
                                                (-1.0         1        -1.0)
                                                (-.1          1        -0.1)
                                                (10           1        10.0)
                                                (100          1       100.0)
                                                (100.001      6       100.001)
                                                (100.000      1       100.0)
                                                (00123.456000 6       123.456)
                                                (-0.00000001  1        -0.00000001)
                                                (-00123.456000 3     -123.0)
                                                (00123.456000 3       123.0)
                                                (0.000000011574074074074074074  10 0.00000001157407407)
                                                (-0.000000011574074074074074074  10 -0.00000001157407407)
                                                (0.0002777777777777777777777777777777778 34 0.0002777777777777777777777777777777778)
                                                (0.0002777777777777777777777777777777778 24 0.000277777777777777777777778)
                                                (0.0002777777777777777777777777777777778 4 0.0002778)
                                            }
                                        BIND(nf:decimal.roundToPrecision(?input, ?precision) AS ?actual)
                                        FILTER(BOUND(?actual) != BOUND(?expectedOutput) || ?actual != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <add>
                                    <file>src/main/rdf/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl</file>
                                </add>
                                <assert>
                                    <message>Test qfn:localname()</message>
                                    <failureMessage>Unit test failed for qfn:localname()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                            VALUES (?input ?expectedOutput) {
                                                (xsd:int            "int")
                                                (unit:M          "M")
                                            }
                                        BIND(qfn:localname(?input) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.getDimensionExponentFromLocalname()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.getDimensionExponentFromLocalname()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVecLocalname ?dimension ?expectedOutput) {
                                                ("A0E0L1I0M0H0T0D0"  "A"  0)
                                                ("A0E0L1I0M0H3T0D0"  "L"  1)
                                                ("A0E0L1I0M0H3T0D0"  "H"  3)
                                            }
                                        BIND(qfn:dimVec.getDimensionExponentFromLocalname(?dimVecLocalname, ?dimension) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.getDimensionExponent()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.getDimensionExponent()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVec ?dimension ?expectedOutput) {
                                                (qkdv:A0E0L1I0M0H0T0D0  "A"  0)
                                                (qkdv:A0E0L1I0M0H3T0D0  "L"  1)
                                                (qkdv:A0E0L1I0M0H3T0D0  "H"  3)
                                            }
                                        BIND(qfn:dimVec.getDimensionExponent(?dimVec, ?dimension) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.pow()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.pow()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVec ?exp ?expectedOutput) {
                                                (qkdv:A0E0L1I0M0H0T0D0  1 qkdv:A0E0L1I0M0H0T0D0  )
                                                (qkdv:A0E0L1I0M0H0T0D0  2 qkdv:A0E0L2I0M0H0T0D0  )
                                                (qkdv:A0E0L1I0M0H0T0D0 -2 qkdv:A0E0L-2I0M0H0T0D0 )
                                                (qkdv:A0E0L1I0M0H0T0D0 -1 qkdv:A0E0L-1I0M0H0T0D0 )
                                            }
                                        BIND(qfn:dimVec.pow(?dimVec, ?exp) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.fromLocalname()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.fromLocalname()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVecLocalname ?expectedOutput) {
                                                ("A0E0L1I0M0H0T0D0" qkdv:A0E0L1I0M0H0T0D0)
                                                ("A1E0L1I0M0H0T0D0" qkdv:A1E0L1I0M0H0T0D0)
                                                ("A1E0L1I0M0H0T0D1" qkdv:A1E0L1I0M0H0T0D0)
                                                ("A0E0L0I0M0H0T0D1" qkdv:A0E0L0I0M0H0T0D1)
                                                ("A0E0L0I0M0H0T0D0" qkdv:A0E0L0I0M0H0T0D1)
                                            }
                                            BIND(qfn:dimVec.fromLocalname(?dimVecLocalname) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.multiply()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.multiply()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?leftDimVec ?rightDimVec ?expectedOutput) {
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L0I0M0H1T0D0  qkdv:A0E0L1I0M0H1T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L0I0M1H1T0D0  qkdv:A0E0L1I0M1H1T0D0)
                                                (qkdv:A0E0L1I0M1H0T0D0 qkdv:A0E0L0I0M1H1T0D0  qkdv:A0E0L1I0M2H1T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L1I0M0H0T0D0  qkdv:A0E0L2I0M0H0T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L-3I0M0H0T0D0 qkdv:A0E0L-2I0M0H0T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L-1I0M0H0T0D0 qkdv:A0E0L0I0M0H0T0D1)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L0I0M0H0T0D1  qkdv:A0E0L1I0M0H0T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 undef                  qkdv:A0E0L1I0M0H0T0D0)
                                                (undef                 qkdv:A0E0L1I0M0H0T0D0  qkdv:A0E0L1I0M0H0T0D0)
                                                (undef                 undef                  qfn:Unbound)
                                            }
                                            BIND(qfn:dimVec.multiply(?leftDimVec, ?rightDimVec) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:unit.dimVec.calculate()</message>
                                    <failureMessage>Unit test failed for qfn:unit.dimVec.calculate()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?unit ?expectedOutput) {
                                                (unit:J             qkdv:A0E0L2I0M1H0T-2D0  )
                                                (unit:W             qkdv:A0E0L2I0M1H0T-3D0  )
                                                (unit:IN            qkdv:A0E0L1I0M0H0T0D0  )
                                                (unit:M             qfn:Unbound )
                                            }
                                            BIND(qfn:unit.dimVec.calculate(?unit) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>

                            </steps>
                            </pipeline>
                        </configuration>
                    </execution>

                    <execution>
                        <id>fix-src</id>
                        <phase>none</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                        <pipeline>
                            <id>fix-src</id>
                            <steps>
                                <shaclFunctions>
                                    <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                </shaclFunctions>
                                <add>
                                    <files>
                                        <include>src/main/rdf/vocab/unit/*.ttl</include>
                                    </files>
                                    <toGraphsPattern>src:${name}</toGraphsPattern>
                                </add>
                                <add>
                                    <files>
                                        <include>target/dist/vocab/**/*.ttl</include>
                                    </files>
                                    <toGraphsPattern>dist:vocab:${name}</toGraphsPattern>
                                </add>
                                <add>
                                    <files>
                                        <include>target/dist/schema/**/*.ttl</include>
                                    </files>
                                    <toGraphsPattern>dist:schema:${name}</toGraphsPattern>
                                </add>
                                <when>
                                    <message>Checking if we have at least the dist units file</message>
                                    <sparqlAsk>
                                        <![CDATA[
                                            ASK WHERE {
                                                FILTER NOT EXISTS {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?s ?p ?o
                                                    }
                                                }
                                            }
                                        ]]>
                                    </sparqlAsk>
                                    <body>
                                        <stop>
                                            <message>

                                                the fix-src pipeline cannot be run without the results
                                                of a previous build being available in the target folder.

                                                Run

                                                mvn install

                                                and when that fails, run

                                                mvn -Pfix install

                                                (as you'll be instructed, hopefully)
                                            </message>
                                        </stop>
                                    </body>
                                </when>


                                <sparqlUpdate>
                                    <sparql>
                                        <![CDATA[
                                            DELETE {
                                                GRAPH <src:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit
                                                        qudt:conversionMultiplier ?cm ;
                                                        qudt:conversionMultiplierSN ?cmSN ;
                                                        qudt:symbol ?symbol ;
                                                        qudt:dimensionVector ?dv ;
                                                }
                                            }
                                            INSERT {
                                                GRAPH <src:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit
                                                        qudt:conversionMultiplier ?new_cm;
                                                        qudt:conversionMultiplierSN ?new_cmSN ;
                                                        qudt:symbol ?new_symbol ;
                                                        qudt:hasDimensionVector ?new_dv ;
                                                }
                                            }
                                            WHERE {
                                                GRAPH <dist:schema:SCHEMA_QUDT_NoOWL.ttl> {
                                                        ?type rdfs:subClassOf+ qudt:Unit
                                                }
                                                GRAPH <src:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit a ?type .
                                                    OPTIONAL{
                                                        ?unit qudt:conversionMultiplier ?cm
                                                    }
                                                    OPTIONAL {
                                                        ?unit qudt:conversionMultiplierSN ?cmSN
                                                    }
                                                    OPTIONAL {
                                                        ?unit qudt:symbol ?symbol
                                                    }
                                                    OPTIONAL {
                                                        ?unit qudt:hasDimensionVector ?dv
                                                    }
                                                }
                                                GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    OPTIONAL{
                                                        ?unit qudt:conversionMultiplier ?new_cm
                                                    }
                                                    OPTIONAL {
                                                        ?unit qudt:conversionMultiplierSN ?new_cmSN
                                                    }
                                                    OPTIONAL {
                                                        ?unit qudt:symbol ?new_symbol
                                                    }
                                                    OPTIONAL {
                                                        ?unit qudt:hasDimensionVector ?new_dv
                                                    }
                                                }
                                            }
                                        ]]>
                                    </sparql>
                                </sparqlUpdate>







                                <write>
                                    <graphs>
                                        <include>src:*</include>
                                    </graphs>
                                </write>
                            </steps>
                        </pipeline>
                        </configuration>
                    </execution>


                    <execution>
                        <id>main</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                            <pipeline>
                                <id>main</id>
                                <steps>
                                    <!-- make custom shacl functions available in inference and SPARQL-->
                                    <shaclFunctions>
                                        <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                    </shaclFunctions>
                                    <!-- first, handle the IEC links -->
                                    <add>
                                        <!--
                                            this reads each file in target into a graph named 'target:{filename}'
                                            in the dataset and remembers the file association (see <write> at the end)
                                        -->
                                        <files>
                                            <include>target/work/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>dist:vocab:${name}</toGraphsPattern>
                                    </add>
                                    <add>
                                        <files>
                                            <include>target/work/schema/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>dist:schema:${name}</toGraphsPattern>
                                    </add>

                                    <sparqlUpdate>
                                        <message>change graph-file associations from target/work to target/dist</message>
                                        <sparql>
                                            <![CDATA[
                                                prefix rdfio: <https://github.com/qudtlib/rdfio/>
                                                DELETE {
                                                    GRAPH <rdfio:pipeline:metadata> {
                                                        ?file rdfio:loadsInto ?graph .
                                                    }
                                                } INSERT {
                                                    GRAPH <rdfio:pipeline:metadata> {
                                                        ?newFile rdfio:loadsInto ?graph .
                                                    }
                                                } WHERE {
                                                    GRAPH <rdfio:pipeline:metadata> {
                                                        ?file rdfio:loadsInto ?graph .
                                                    }
                                                    BIND (IRI(REPLACE(STR(?file), "target/work", "target/dist")) AS ?newFile)
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <sparqlUpdate>
                                        <message>Adding IEC links</message>
                                        <sparql>
                                            <![CDATA[
                                            INSERT {
                                                GRAPH ?g {
                                                    ?x qudt:informativeReference ?new}
                                                }
                                            WHERE {
                                                GRAPH ?g {
                                                    ?x a ?type; qudt:iec61360Code ?irdi.
                                                    VALUES (?type ?prefix) {
                                                        (qudt:Unit         "https://cdd.iec.ch/cdd/iec62720/iec62720.nsf/Units/")
                                                        (qudt:QuantityKind "https://cdd.iec.ch/cdd/iec61987/iec61987.nsf/ListsOfUnitsAllVersions/")
                                                        (qudt:PhysicalConstant "https://cdd.iec.ch/cdd/iec61987/iec61987.nsf/ListsOfUnitsAllVersions/")
                                                    }
                                                    OPTIONAL {
                                                        ?x qudt:informativeReference ?old filter(strstarts(str(?old),"https://cdd.iec.ch"))
                                                    }
                                                    BIND(replace(replace(str(?irdi),"/","-"),"#","%23") as ?irdi_new)
                                                    BIND(strdt(concat(?prefix,?irdi_new),xsd:anyURI) as ?new)
                                                }
                                            }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <savepoint><id>01-iec-links</id></savepoint>

                                    <add> <!-- load applicableUnits shapes (rules) into <shapes:applicableUnits> because we need them twice (see below) -->
                                        <file>src/build/inference/inferApplicableUnits.ttl</file>
                                        <toGraph>shapes:applicableUnits</toGraph>
                                    </add>

                                    <shaclInfer> <!-- do the quantitykinds inference -->
                                        <message>Inferring qudt:applicableUnit triples (non-currency units)</message>
                                        <shapes>
                                            <graph>shapes:applicableUnits</graph>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>dist:vocab:VOCAB_QUDT-QUANTITY-KINDS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:applicableUnits</graph>
                                            <file>target/inferred/applicableUnits.ttl</file>
                                        </inferred>
                                    </shaclInfer>

                                    <add> <!-- add the results of the quantitykinds inference to the quantityKinds graph -->
                                        <graph>inferred:applicableUnits</graph>
                                        <toGraph>dist:vocab:VOCAB_QUDT-QUANTITY-KINDS-ALL.ttl</toGraph>
                                    </add>

                                    <!-- start from here if nothing has changed in the inputs of the earlier steps -->
                                    <savepoint><id>02-applicableUnits</id></savepoint>
                                    <shaclInfer>  <!-- do the quantitykinds inference for currency units -->
                                        <message>Inferring qudt:applicableUnit triples (currency units)</message>
                                        <shapes><graph>shapes:applicableUnits</graph></shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-CURRENCY.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:applicableCurrencyUnits</graph>
                                            <file>target/inferred/applicableUnits-currency.ttl</file>
                                        </inferred>
                                    </shaclInfer>
                                    <add>
                                        <graph>inferred:applicableCurrencyUnits</graph>
                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-CURRENCY.ttl</toGraph>
                                    </add>

                                    <!-- start from here if nothing has changed in the inputs of the earlier steps -->
                                    <savepoint><id>03-applicableUnits-currencies</id></savepoint>

                                    <sparqlUpdate>
                                        <message>Set conversionMultiplier of 1.0 on each currency unit</message>
                                        <sparql>
                                            <![CDATA[
                                                INSERT {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?cur qudt:conversionMultiplier 1.0
                                                    }
                                                } WHERE  {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?cur a qudt:CurrencyUnit
                                                        FILTER(REGEX(qfn:localname(?cur),"CCY_\\w+"))
                                                        FILTER NOT EXISTS {
                                                            ?cur qudt:conversionMultiplier ?cm
                                                        }
                                                    }
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>

                                    <shaclInfer> <!-- do the custom OWL subset inference -->
                                        <message>Performing our custom subset of OWL inferences</message>
                                        <shapes>
                                            <file>src/build/inference/owl-subset.shapes.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:owl-subset-units</graph>
                                            <file>target/inferred/owl-subset-units.ttl</file>
                                        </inferred>
                                    </shaclInfer>

                                    <add> <!-- add the inferred triples to the units graph -->
                                        <graph>inferred:owl-subset-units</graph>
                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>

                                    <!-- start from here if nothing has changed in the inputs of the earlier steps -->
                                    <savepoint><id>04-owl-subset-units</id></savepoint>

                                    <add>
                                        <file>src/build/inference/factorUnits/predefined-factors-and-scalings.ttl</file>
                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>

                                    <shaclInfer> <!-- infer the factor units -->
                                        <message>Inferring qudt:hasFactorUnit</message>
                                        <shapes>
                                            <file>target/srcgen/factorUnits/infer.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graphs>
                                                <include>
                                                    dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl
                                                    dist:vocab:VOCAB_QUDT-PREFIXES.ttl
                                                </include>
                                            </graphs>
                                        </data>
                                        <inferred>
                                            <graph>inferred:factorUnits</graph>
                                            <file>target/inferred/factorUnits.ttl</file>
                                        </inferred>
                                    </shaclInfer>
                                    <add>
                                        <graph>inferred:factorUnits</graph>
                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>
                                    <savepoint><id>05-infer-factor-units</id></savepoint>
                                    <shaclInfer>
                                        <message>Inferring qudt:scalingOf</message>
                                        <shapes>
                                            <file>target/srcgen/scalingOf/infer.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:scalingOf</graph>
                                            <file>target/inferred/scalingOf.ttl</file>
                                        </inferred>
                                    </shaclInfer>
                                    <add>
                                        <graph>inferred:scalingOf</graph>
                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>
                                    <savepoint><id>06.1-infer-scalingOf-with-errors</id></savepoint>
                                    <sparqlUpdate>
                                        <message>Fix unit:GM/unit:KiloGM qudt:scalingOf situation</message>
                                        <sparql>
                                            <![CDATA[
                                                DELETE {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        unit:KiloGM qudt:scalingOf unit:GM
                                                    }
                                                } INSERT {
                                                   GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        unit:GM qudt:scalingOf unit:KiloGM
                                                   }
                                                } WHERE {}
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <savepoint><id>06-infer-scalingOf</id></savepoint>
                                    <sparqlUpdate>
                                        <message>Copy conversionMultipliers/offsets from qudt:exactMatch|skos:broader unit where not present</message>
                                        <sparql>
                                            <![CDATA[
                                                INSERT {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:conversionMultiplierSN ?cmSN ;
                                                            qudt:conversionOffset ?co ;
                                                            qudt:conversionOffset ?coSN ;
                                                            rdfs:comment ?copyComment .
                                                    }
                                                }
                                                WHERE {
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl>  {
                                                        ?unit a qudt:Unit .
                                                        FILTER NOT EXISTS {
                                                            ?unit
                                                                qudt:conversionMultiplier [] ;
                                                                qudt:conversionMultiplierSN [] ;
                                                            OPTIONAL {
                                                                ?unit
                                                                    qudt:conversionOffset [];
                                                                    qudt:conversionOffsetSN [] .
                                                            }
                                                        }
                                                        ?unit ?rel ?otherUnit .
                                                        FILTER(?rel IN (qudt:exactMatch,skos:broader))
                                                        ?otherUnit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:conversionMultiplierSN ?cmSN .
                                                        OPTIONAL {
                                                            ?otherUnit
                                                                qudt:conversionOffset ?co ;
                                                                qudt:conversionOffsetSN ?coSN .
                                                        }
                                                        BIND(CONCAT("qudt:conversionMultiplier copied from unit ", STR(?otherUnit), " via relation ", STR(?rel)) AS ?copyComment)
                                                    }
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <shaclValidate>
                                        <message>Validating qudt:hasDimensionVector (making sure none are missing that cannot be derived)</message>
                                        <shapes>
                                            <file>src/build/srcgen/dimensionVector/prerequisite.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <validationReport>
                                            <graph>validation:dimensionVector-underivable.ttl</graph>
                                            <file>target/validation/dimensionVector-underivable.ttl.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                    <until>
                                        <message>Add missing dimension vectors that can be inferred</message>
                                        <indexVar>index_dv</indexVar>
                                        <body>
                                            <shaclInfer>
                                                <message>Inferring missing qudt:dimensionVector</message>
                                                <iterateUntilStable>true</iterateUntilStable>
                                                <iterationOutputFilePattern>target/inferred/dimensionVector-${index_dv}_${index}.ttl</iterationOutputFilePattern>
                                                <shapes>
                                                    <file>target/srcgen/dimensionVector/infer.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                </data>
                                                <inferred>
                                                    <graph>inferred:dimensionVector_${index_dv}</graph>
                                                    <file>target/inferred/dimensionVector_${index_dv}.ttl</file>
                                                </inferred>
                                            </shaclInfer>
                                            <add>
                                                <graph>inferred:dimensionVector_${index_dv}</graph>
                                                <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                            </add>
                                        </body>
                                        <sparqlAsk>
                                            ASK {
                                                BIND(IRI(CONCAT("inferred:dimensionVector_",STR(?index_dv))) as ?graph)
                                                FILTER NOT EXISTS {
                                                    GRAPH ?graph {
                                                        ?s ?p ?o
                                                    }
                                                }
                                            }
                                        </sparqlAsk>
                                    </until>
                                    <savepoint><id>07-infer-dimensionVector</id></savepoint>
                                    <until>
                                        <message>Checking for missing/wrong symbols that can be corrected/inferred</message>
                                        <indexVar>iteration</indexVar>
                                        <body>
                                            <clear>
                                                <graph>inferred:symbol</graph>
                                                <graph>delete:symbol</graph>
                                            </clear>
                                            <shaclValidate>
                                                <failOnSeverity>None</failOnSeverity>
                                                <message>Preventing qudt:symbol that does not match the symbol calculated from base unit(s)</message>
                                                <shapes>
                                                    <file>target/srcgen/symbol/validate.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                    <file>src/build/srcgen/symbol/units-overriding-inferred-symbol.ttl</file>
                                                </data>
                                                <validationReport>
                                                    <graph>delete:symbol</graph>
                                                    <file>target/fix/symbol/delete-${iteration}.ttl</file>
                                                </validationReport>
                                            </shaclValidate>
                                            <when>
                                                <sparqlAsk>
                                                    <![CDATA[
                                                        ASK WHERE {
                                                            GRAPH <delete:symbol> {
                                                                [] a sh:ValidationReport ;
                                                                   sh:conforms false .
                                                            }
                                                        }
                                                    ]]>
                                                </sparqlAsk>
                                                <body>
                                                    <sparqlUpdate>
                                                        <message>Deleting invalid symbols</message>
                                                        <sparql>
                                                            <![CDATA[
                                                        DELETE {
                                                            GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                ?unit qudt:symbol ?incorrectSymbol .
                                                            }
                                                            GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                ?unit qudt:symbol ?incorrectSymbol .
                                                            }
                                                        }
                                                        WHERE {
                                                            GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                {
                                                                    ?unit qudt:symbol ?incorrectSymbol .
                                                                }
                                                            }
                                                            GRAPH <delete:symbol> {
                                                                ?res
                                                                    rdf:type                      sh:ValidationResult;
                                                                    sh:resultPath                 qudt:symbol;
                                                                    sh:resultSeverity             sh:Violation;
                                                                    sh:value                      ?unit
                                                            }
                                                        }
                                                        ]]>
                                                        </sparql>
                                                    </sparqlUpdate>
                                                    <shaclInfer>
                                                        <message>Inferring missing qudt:symbol</message>
                                                        <!-- it would be nice to iterate, but if we do that, we end up adding triples without
                                                            deleting the incorrect versions. we have to go through main-fixSrc-main-fixSrc...
                                                            as often as it takes.
                                                        -->
                                                        <iterateUntilStable>false</iterateUntilStable>
                                                        <shapes>
                                                            <file>target/srcgen/symbol/infer.ttl</file>
                                                        </shapes>
                                                        <data>
                                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                            <file>src/build/srcgen/symbol/units-overriding-inferred-symbol.ttl</file>
                                                        </data>
                                                        <inferred>
                                                            <graph>inferred:symbol</graph>
                                                            <file>target/fix/symbol/inferred-${iteration}.ttl</file>
                                                        </inferred>
                                                    </shaclInfer>
                                                    <add>
                                                        <graph>inferred:symbol</graph>
                                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                                    </add>
                                                </body>
                                            </when>
                                        </body>
                                        <sparqlAsk>
                                            <![CDATA[
                                            ASK WHERE {
                                              FILTER NOT EXISTS {
                                                    GRAPH <inferred:symbol> {
                                                        ?s ?p ?o
                                                    }
                                                }
                                            }
                                        ]]>
                                        </sparqlAsk>
                                    </until>
                                    <savepoint><id>08-infer-symbol</id></savepoint>
                                    <until>
                                        <message>Checking for conversion multipliers with wrong precision</message>
                                        <indexVar>iteration</indexVar>
                                        <body>
                                            <clear>
                                                <graph>delete:conversionMultiplierPrecision</graph>
                                                <graph>inferred:conversionMultiplierPrecision</graph>
                                            </clear>
                                            <shaclValidate>
                                                <message>Validating qudt:conversionMultiplier precision</message>
                                                <!-- we don't want to fail, we want to know the errors so we can delete triples-->
                                                <failOnSeverity>None</failOnSeverity>
                                                <shapes>
                                                    <file>target/srcgen/conversionMultiplierPrecision/validate.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                </data>
                                                <validationReport>
                                                    <graph>delete:conversionMultiplierPrecision</graph>
                                                    <file>target/fix/precision/delete-${iteration}.ttl</file>
                                                </validationReport>
                                            </shaclValidate>

                                            <when>
                                                <message>If there are problems with conversion multiplier precision, fix them</message>
                                                <sparqlAsk>
                                                    <![CDATA[
                                                        ASK WHERE {
                                                            GRAPH <delete:conversionMultiplierPrecision> {
                                                                [] a sh:ValidationReport ;
                                                                    sh:conforms false .
                                                            }
                                                        }
                                                    ]]>
                                                </sparqlAsk>


                                                <body>
                                                    <shaclInfer>
                                                        <!-- first infer correct from incorrect, then delete incorrect! -->
                                                        <message>Inferring qudt:conversionMultiplier with correct precision</message>
                                                        <shapes>
                                                            <file>target/srcgen/conversionMultiplierPrecision/infer.ttl</file>
                                                        </shapes>
                                                        <data>
                                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                        </data>
                                                        <inferred>
                                                            <graph>inferred:conversionMultiplierPrecision</graph>
                                                            <file>target/fix/precision/inferred-${iteration}.ttl</file>
                                                        </inferred>
                                                    </shaclInfer>

                                                    <sparqlUpdate>
                                                        <!-- delete incorrect after inferring correct! -->
                                                        <message>Deleting conversion multipliers with wrong precision</message>
                                                        <sparql>
                                                            <![CDATA[
                                                        DELETE {
                                                            GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                ?unit
                                                                    qudt:conversionMultiplier ?m ;
                                                                    qudt:conversionMultiplierSN ?mSN .
                                                            }
                                                        }
                                                        WHERE {
                                                            GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                {
                                                                    ?unit qudt:conversionMultiplier ?m .
                                                                } UNION {
                                                                    ?unit qudt:conversionMultiplierSN ?mSN .
                                                                }
                                                            }
                                                            GRAPH <delete:conversionMultiplierPrecision> {
                                                                ?res
                                                                    rdf:type                      sh:ValidationResult;
                                                                    sh:resultPath                 qudt:conversionMultiplier;
                                                                    sh:resultSeverity             sh:Violation;
                                                                    sh:value                      ?unit
                                                            }
                                                        }
                                                        ]]>
                                                        </sparql>
                                                    </sparqlUpdate>

                                                    <add>
                                                        <graph>inferred:conversionMultiplierPrecision</graph>
                                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                                    </add>
                                                </body>

                                            </when>

                                        </body>
                                        <sparqlAsk>
                                            <![CDATA[
                                                ASK WHERE {
                                                  FILTER NOT EXISTS {
                                                        GRAPH <inferred:conversionMultiplierPrecision> {
                                                            ?s ?p ?o
                                                        }
                                                    }
                                                }
                                            ]]>
                                        </sparqlAsk>
                                    </until>
                                    <savepoint><id>09-infer-precision</id></savepoint>

                                    <until>
                                        <message>Checking for wrong conversion multipliers compared with factors/bases</message>
                                        <indexVar>iteration</indexVar>
                                        <body>
                                            <clear>
                                                <graph>delete:conversionMultiplier</graph>
                                                <graph>inferred:conversionMultiplier</graph>
                                            </clear>
                                            <shaclValidate>
                                                <message>Validating qudt:conversionMultiplier</message>
                                                <!-- we don't want to fail, we want to know the errors so we can delete triples-->
                                                <failOnSeverity>None</failOnSeverity>
                                                <shapes>
                                                    <file>target/srcgen/conversionMultiplier/validate.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                </data>
                                                <validationReport>
                                                    <graph>delete:conversionMultiplier</graph>
                                                    <file>target/fix/conversionMultiplier/delete-${iteration}.ttl</file>
                                                </validationReport>
                                            </shaclValidate>
                                            <when>
                                                <message>If there are problems with conversion multipliers, fix them</message>
                                                <sparqlAsk>
                                                    <![CDATA[
                                                        ASK WHERE {
                                                            GRAPH <delete:conversionMultiplier> {
                                                                [] a sh:ValidationReport ;
                                                                    sh:conforms false .
                                                            }
                                                        }
                                                    ]]>
                                                </sparqlAsk>
                                                <body>
                                                    <sparqlUpdate>
                                                        <message>Deleting invalid conversion multipliers</message>
                                                        <sparql>
                                                            <![CDATA[
                                                            DELETE {
                                                                GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                    ?unit qudt:conversionMultiplier ?m .
                                                                    ?unit  qudt:conversionMultiplierSN ?mSN .
                                                                }
                                                            }
                                                            WHERE {
                                                                GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                                    {
                                                                        ?unit qudt:conversionMultiplier ?m .
                                                                    } UNION {
                                                                        ?unit qudt:conversionMultiplierSN ?mSN .
                                                                    }
                                                                }
                                                                GRAPH <delete:conversionMultiplier> {
                                                                    ?res
                                                                        rdf:type                      sh:ValidationResult;
                                                                        sh:resultPath                 qudt:conversionMultiplier;
                                                                        sh:resultSeverity             sh:Violation;
                                                                        sh:value                      ?unit
                                                                }
                                                            }
                                                            ]]>
                                                        </sparql>
                                                    </sparqlUpdate>

                                                    <shaclInfer>
                                                        <message>Inferring qudt:conversionMultiplier where missing</message>
                                                        <iterateUntilStable>false</iterateUntilStable>
                                                        <shapes>
                                                            <file>target/srcgen/conversionMultiplier/infer.ttl</file>
                                                        </shapes>
                                                        <data>
                                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                        </data>
                                                        <inferred>
                                                            <graph>inferred:conversionMultiplier</graph>
                                                            <file>target/fix/conversionMultiplier/inferred-${iteration}.ttl</file>
                                                        </inferred>
                                                    </shaclInfer>
                                                    <add>
                                                        <graph>inferred:conversionMultiplier</graph>
                                                        <toGraph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                                    </add>

                                                </body>
                                            </when>
                                        </body>
                                        <sparqlAsk>
                                            <![CDATA[
                                                ASK WHERE {
                                                  FILTER NOT EXISTS {
                                                        GRAPH <inferred:conversionMultiplier> {
                                                            ?s ?p ?o
                                                        }
                                                    }
                                                }
                                            ]]>
                                        </sparqlAsk>
                                    </until>




                                    <sparqlUpdate>
                                        <message>Set conversionMultiplier to 0.0 for any unit that does not have that triple</message>
                                        <sparql>
                                            <![CDATA[
                                                INSERT {
                                                    GRAPH ?graph {
                                                        ?unit qudt:conversionMultiplier 0.0
                                                    }
                                                } WHERE {
                                                    GRAPH ?graph {
                                                        ?unit rdf:type/rdfs:subClassOf* qudt:Unit
                                                        FILTER NOT EXISTS {
                                                            ?unit qudt:conversionMultiplier ?cm
                                                        }
                                                    }
                                                    FILTER(CONTAINS(STR(?graph),"dist:vocab:VOCAB"))
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>


                                    <sparqlUpdate>
                                        <message>Generate conversion multipliers in xsd:double format where it's missing</message>
                                        <sparql>
                                            <![CDATA[
                                            INSERT {
                                                GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit qudt:conversionMultiplierSN ?cmsn
                                                }
                                            }
                                            WHERE {
                                                GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit a qudt:Unit ;
                                                          qudt:conversionMultiplier ?cm .
                                                    FILTER NOT EXISTS {
                                                        ?unit qudt:conversionMultiplierSN ?any .
                                                    }
                                                    BIND(qfn:decimalToDouble(?cm) as ?cmsn)
                                                }
                                            }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <savepoint><id>10-infer-conversionMultiplier</id></savepoint>

                                    <sparqlUpdate>
                                        <message>Limit any xsd:decimal's precision to 34</message>
                                        <sparql>
                                        <![CDATA[
                                        PREFIX nf: <https://github.com/qudtlib/numericFunctions/>
                                        DELETE {
                                            GRAPH ?g {
                                                ?s ?p ?oldVal .
                                                ?s ?pSN ?oldValSN .
                                            }
                                        }
                                        INSERT {
                                            GRAPH ?g {
                                                ?s ?p ?newVal .
                                                ?s ?pSN ?newValSN .
                                            }
                                        }
                                        WHERE {
                                           GRAPH ?g {
                                                ?s ?p ?oldVal .
                                                FILTER (DATATYPE(?oldVal) = xsd:decimal)
                                                FILTER(qfn:decimalPrecision(?oldVal) > 34)
                                                BIND(IRI(CONCAT(STR(?p),"SN")) as ?pSN)
                                                BIND(nf:decimal.roundToPrecision(?oldVal, 34) AS ?newVal)
                                                BIND(qfn:decimalToDouble(?newVal) AS ?newValSN)
                                                OPTIONAL {
                                                    ?s ?pSN ?oldValSN .
                                                }
                                           }
                                        }
                                        ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <add>
                                        <files>
                                            <include>src/main/rdf/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>src:vocab:${name}</toGraphsPattern>
                                    </add>

                                    <write>
                                        <graphs>
                                            <include>dist:vocab:*</include>
                                        </graphs>
                                    </write>

                                    <when>
                                        <message>Fail the build if the src has to be updated</message>
                                        <sparqlAsk>
                                            <![CDATA[
                                                ASK WHERE {
                                                    GRAPH <dist:schema:SCHEMA_QUDT_NoOWL.ttl> {
                                                            ?type rdfs:subClassOf+ qudt:Unit
                                                    }
                                                    GRAPH <src:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit a ?type .
                                                        OPTIONAL{
                                                            ?unit qudt:conversionMultiplier ?cm
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:conversionMultiplierSN ?cmSN
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:symbol ?symbol
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:hasDimensionVector ?dv
                                                        }
                                                    }
                                                    GRAPH <dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        OPTIONAL{
                                                            ?unit qudt:conversionMultiplier ?new_cm
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:conversionMultiplierSN ?new_cmSN
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:symbol ?new_symbol
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:hasDimensionVector ?new_dv
                                                        }
                                                    }
                                                    FILTER(
                                                        COALESCE(?cm,"NOT BOUND") != COALESCE(?new_cm, "NOT BOUND")
                                                        || COALESCE(?cmSN,"NOT BOUND") != COALESCE(?new_cmSN, "NOT BOUND")
                                                        || COALESCE(?symbol,"NOT BOUND") != COALESCE(?new_symbol, "NOT BOUND")
                                                        || COALESCE(?dv,"NOT BOUND") != COALESCE(?new_dv, "NOT BOUND")
                                                    )
                                                }
                                            ]]>
                                        </sparqlAsk>

                                        <body>
                                            <stop>
                                                <message>
                                                    Data errors in src/main/rdf/dist!

                                                    to fix the errors in `src`, do NOT run mvn clean - the
                                                    current build output is needed!
                                                    Just run:

                                                    mvn -Pfix install


                                                    Please review the changes that are made to the sources.
                                                    There may be more information on individual changes in

                                                    target/fix/[topic]/delete-[iteration].ttl
                                                </message>
                                            </stop>
                                        </body>
                                    </when>


                                    <savepoint><id>99-endOfPipeline</id></savepoint>
                                </steps>
                            </pipeline>
                        </configuration>
                    </execution>

                    <execution>
                        <!--
                        SHACL-validates the union of all ttl files in dist/vocab and the No-OWL schema
                        against the union of QA-Tests and No-OWL schema
                        writes the validation report target/validation/validationReport.ttl
                        -->
                        <id>validate-dist</id>
                        <phase>test</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                            <pipeline>
                                <id>validate-dist</id>
                                <steps>
                                    <shaclFunctions>
                                        <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                    </shaclFunctions>
                                    <add>
                                        <files>
                                            <include>target/dist/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>dist:vocab:${name}</toGraphsPattern>
                                    </add>
                                    <add>
                                        <files>
                                            <include>target/dist/schema/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>dist:schema:${name}</toGraphsPattern>
                                    </add>
                                    <shaclValidate>
                                        <message>Validating QUDT build output (target/dist/)</message>
                                        <!--skip>true</skip-->
                                        <shapes>
                                            <files>
                                                <include>
                                                    src/main/rdf/validation/COLLECTION_QUDT_QA_TESTS_ALL.ttl
                                                    src/main/rdf/validation/COLLECTION_QUDT_USER_TESTS.ttl
                                                    src/main/rdf/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                                    src/main/rdf/schema/shacl/SCHEMA_QUDT-DATATYPES_NoOWL.ttl
                                                </include>
                                            </files>
                                        </shapes>
                                        <data>
                                            <graphs>
                                                <include>
                                                    dist:schema:SCHEMA_QUDT_NoOWL.ttl
                                                    dist:vocab:*
                                                </include>
                                            </graphs>
                                        </data>
                                        <validationReport>
                                            <file>target/validation/validationReport.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                    <shaclValidate>
                                        <message>Validating QUDT conversion multipliers</message>
                                        <shapes>
                                            <file>target/srcgen/factorUnits/validate.ttl</file>
                                        </shapes>
                                        <data>
                                            <graph>dist:schema:SCHEMA_QUDT.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <validationReport>
                                            <file>target/validation/validationReport-factorUnits.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                    <shaclValidate>
                                        <message>Validating QUDT factor units</message>
                                        <shapes>
                                            <file>target/srcgen/factorUnits/validate.ttl</file>
                                        </shapes>
                                        <data>
                                            <graph>dist:schema:SCHEMA_QUDT.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <validationReport>
                                            <file>target/validation/validationReport-factorUnits.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                    <shaclValidate>
                                        <message>Validating QUDT scalingOf</message>
                                        <shapes>
                                            <file>target/srcgen/scalingOf/validate.ttl</file>
                                        </shapes>
                                        <data>
                                            <graph>dist:schema:SCHEMA_QUDT.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <validationReport>
                                            <file>target/validation/validationReport-scalingOf.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                    <shaclValidate>
                                        <!-- if this validation fails, fixSrc can fix the problem -->
                                        <failOnSeverity>Violation</failOnSeverity>
                                        <message>Preventing qudt:symbol that does not match the symbol calculated from base unit(s)</message>
                                        <shapes>
                                            <file>target/srcgen/symbol/validate.ttl</file>
                                        </shapes>
                                        <data>
                                            <graph>dist:schema:SCHEMA_QUDT.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>dist:vocab:VOCAB_QUDT-PREFIXES.ttl</graph>
                                            <file>src/build/srcgen/symbol/units-overriding-inferred-symbol.ttl</file>
                                        </data>
                                        <validationReport>
                                            <file>target/validation/symbol.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                </steps>
                            </pipeline>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>com.diffplug.spotless</groupId>
                <artifactId>spotless-maven-plugin</artifactId>
                <version>2.44.0.BETA3</version>
                <configuration>
                        <!-- default configuration - this is the one that is used if the plugin is
                        invoked directly using `mvn spotless:apply` or `mvn spotless:check`
                        -->
                        <rdf>
                            <includes>
                                <include>src/main/rdf/**/*.ttl</include>
                                <include>src/build/**/*.ttl</include>
                                <include>target/dist/**/*.ttl</include>
                                <exclude>target/validation/</exclude>
                            </includes>
                            <format>
                                <failOnWarning>false</failOnWarning>
                                <verify>true</verify>
                                <turtleFormatterVersion>1.2.16</turtleFormatterVersion>
                                <turtle>
                                    <predicateOrder>rdf:type,owl:imports</predicateOrder>
                                    <firstPredicateInNewLine>true</firstPredicateInNewLine>
                                </turtle>
                            </format>
                        </rdf>
                    <markdown>
                        <includes>
                            <include>**/*.md</include>
                        </includes>
                        <flexmark />
                    </markdown>

                    <formats>
                        <!--
                        does our placeholder replacements using the maven properties
                        that were set using the groovy plugin
                        -->
                        <format>
                            <includes>
                                <include>target/dist/**/*.*</include>
                            </includes>
                            <excludes>
                                <include>target/**/*.xlsx</include>
                                <include>target/**/*.xls</include>
                                <include>target/**/*.gif</include>
                                <include>target/**/*.zip</include>
                                <include>target/**/*.pdf</include>
                                <include>target/**/*.ppt</include>
                                <include>target/**/*.pptx</include>
                            </excludes>
                            <replaceRegex>
                                <name>full version replacement</name>
                                <searchRegex>\$\$QUDT_VERSION\$\$</searchRegex>
                                <replacement>${project.version}</replacement>
                            </replaceRegex>
                            <replaceRegex>
                                <name>major.minor version replacement</name>
                                <searchRegex>\$\$QUDT_MAJOR_MINOR_VERSION\$\$</searchRegex>
                                <replacement>${project.version.majorminor}</replacement>
                            </replaceRegex>
                            <replace>
                                <name>publish date replacement</name>
                                <search>1234-12-12T12:34:56Z</search>
                                <replacement>${qudt.build.date}</replacement>
                            </replace>
                            <replaceRegex>
                                <name>versioned IRI replacement</name>
                                <searchRegex>http://qudt.org/\d+.\d+/</searchRegex>
                                <replacement>${qudt.versioned.iri.prefix}</replacement>
                            </replaceRegex>
                            <replace>
                                <name>current year</name>
                                <search>$$$$CURRENT_YEAR$$$$</search>
                                <replacement>${qudt.current.year}</replacement>
                            </replace>
                            <replace>
                                <name>current month</name>
                                <search>$$$$CURRENT_MONTH$$$$</search>
                                <replacement>${qudt.current.month}</replacement>
                            </replace>
                            <replace>
                                <name>current year</name>
                                <search>$$$$QUDT_PREV_RELEASE_YEAR$$$$</search>
                                <replacement>${qudtPrevReleaseYear}</replacement>
                            </replace>
                            <replace>
                                <name>current month</name>
                                <search>$$$$QUDT_PREV_RELEASE_MONTH$$$$</search>
                                <replacement>${qudtPrevReleaseMonth}</replacement>
                            </replace>
                        </format>
                    </formats>

                </configuration>
                <executions>
                    <execution>
                        <!--
                            checks formats in all files we care about before anything else
                            happens in the build.

                            Note: The more comfortable alternative would be to
                            start with formatting everything, but we cannot do it: it would allow
                            for a commit to contain non-formatted files. Those files would be formatted
                            during the server-side build but not updated in the repo. A subsequent
                            merge/rebase to our main branch would lead to having unformatted files in
                            the main branch.
                        -->
                        <id>check-src-format</id>
                        <phase>process-sources</phase>
                        <goals>
                            <goal>check</goal>
                        </goals>
                        <configuration>
                            <formats>
                            <!--
                            does our placeholder replacements using the maven properties
                            that were set using the groovy plugin
                            -->
                                <format>
                                    <excludes>
                                        <exclude>target/**/*.*</exclude>
                                    </excludes>
                                </format>
                            </formats>

                            <rdf>
                                <includes>
                                    <include>src/**/*.ttl</include>
                                </includes>
                                <excludes>
                                    <exclude>target/**/*.*</exclude>
                                    <exclude>src/build/srcgen/**/infer.ttl</exclude>
                                    <exclude>src/build/srcgen/**/validate.ttl</exclude>
                                </excludes>
                            </rdf>
                        </configuration>
                    </execution>
                    <execution>
                        <!-- formats source files that were generated during the build up to the compile phase -->
                        <id>reformat-src</id>
                        <phase>none</phase>
                        <goals>
                            <goal>apply</goal>
                        </goals>
                        <configuration>
                            <upToDateChecking>
                                <enabled>false</enabled>
                            </upToDateChecking>
                            <rdf>
                                <!-- redefine includes so we only format the sources that are allowed to change -->
                                <includes>
                                    <include>src/main/rdf/**/*.ttl</include>
                                </includes>
                            </rdf>
                        </configuration>
                    </execution>
                    <execution>
                        <!-- formats everything in the target/dist folder so we have a clean set of distribution files-->
                        <id>format-dist</id>
                        <phase>process-test-classes</phase>
                        <goals>
                            <goal>apply</goal>
                        </goals>
                        <configuration>
                            <upToDateChecking>
                                <enabled>false</enabled>
                            </upToDateChecking>
                            <rdf>
                                <!-- redefine rdf includes to only include target/dist -->
                                <includes>
                                    <include>target/dist/**/*.ttl</include>
                                </includes>
                            </rdf>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <artifactId>maven-resources-plugin</artifactId>
                <version>3.3.1</version>
                <!-- copies all required files from src or root dir to the target folder -->
                <executions>
                    <execution>
                        <id>copy-rdf-to-dist</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/dist</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/rdf</directory>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                    <execution>
                        <id>copy-rdf-to-work</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/work</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/rdf</directory>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                    <execution>
                        <id>copy-docs</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/dist/docs</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/docs</directory>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                    <execution>
                        <id>copy-root-files</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/dist</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>${project.basedir}</directory>
                                    <includes>
                                        <include>*.md</include>
                                    </includes>
                                    <excludes>
                                        <exclude>BUILDING.md</exclude>
                                    </excludes>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-install-plugin</artifactId>
                <version>3.1.2</version>
                <!--
                we want to suppress this plugin, which makes no sense unless we want to
                allow people to use qudt as a maven dependency
                -->
                <executions>
                    <execution>
                        <phase>none</phase>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-deploy-plugin</artifactId>
                <version>3.1.2</version>
                <!--
                we want to suppress this plugin, which makes no sense unless we want to
                allow people to use qudt as a maven dependency AND we want to publish it
                to a maven registry
                -->
                <configuration>
                    <!-- we never want to deploy, our github actions take care of that -->
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <profiles>
        <!--
            profiles are activated using the -P[profileName] command line arg to the mvn command
            if activated, the structure contained in the <profile> element is merged with the pom structure.
        -->
        <profile>
            <!-- profile that causes the zip file to be created -->
            <id>zip</id>
            <build>
                <plugins>
                    <plugin>
                        <artifactId>maven-assembly-plugin</artifactId>
                        <configuration>
                            <descriptors>
                                <descriptor>src/build/assembly/releaseZip.xml</descriptor>
                            </descriptors>
                            <finalName>${project.name}-${project.version}</finalName>
                            <appendAssemblyId>false</appendAssemblyId>
                        </configuration>
                        <executions>
                            <execution>
                                <id>release-zip</id>
                                <goals>
                                    <goal>single</goal>
                                </goals>
                                <phase>install</phase>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <!--
                runs all src modifications (inferences and formatting) before anything else in the build
             -->
            <id>fix</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>com.diffplug.spotless</groupId>
                        <artifactId>spotless-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>reformat-src</id>
                                <phase>initialize</phase>
                            </execution>
                        </executions>
                    </plugin>
                    <plugin>
                        <groupId>io.github.qudtlib</groupId>
                        <artifactId>rdfio-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>fix-src</id>
                                <phase>validate</phase>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>