<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.qudt</groupId>
    <artifactId>qudt-public-repo</artifactId>
    <version>3.1.4-SNAPSHOT</version>
    <packaging>pom</packaging>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <qudtPrevReleaseYear>TODO-set-property-qudtPrevReleaseYear</qudtPrevReleaseYear>
        <qudtPrevReleaseMonth>TODO-set-property-qudtPrevReleaseMonth</qudtPrevReleaseMonth>
        <shacl.severity.log>Violation</shacl.severity.log>
    </properties>
    <scm>
        <connection>scm:git:https://github.com/qudt/qudt-public-repo.git</connection>
        <developerConnection>scm:git:https://github.com/qudt/qudt-public-repo.git</developerConnection>
        <url>https://github.com/qudt/qudt-public-repo/tree/master</url>
      <tag>HEAD</tag>
  </scm>
    <build>
        <!--
            project is built using

            mvn install

            the release zip is built using

            mvn -Pzip install
        -->
        <pluginManagement>
            <plugins>
                <plugin>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>3.3.1</version>
                </plugin>
            </plugins>
        </pluginManagement>
        <plugins>
            <!--
                this section defines the actions taken during the build.
                The build is executed as a series of 'lifecycle phases': https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html)
                Each plugin has an <execution> section that binds its execution to a lifecycle phase (or it has a default lifecycle phase in which it runs, or 'none' for direct invocation).
                Here are the phases and the execution ids that are linked to them (executed in the order they appear in this file):
                      validate                 defineAdditionalProperties, preprocess-shacl-files
                      initialize               [Profile -Pfix: reformat-sources]
                      generate-sources         unitTestPipeline
                      process-sources          check-source-format, shacl-validate-src
                      generate-resources       copy-rdf-to-dist, copy-rdf-to-work, copy-docs, copy-root-files, validate-shacl-files
                      process-resources
                      process-classes          mainRdfPipeline
                      generate-test-sources
                      process-test-sources     all-in-one
                      generate-test-resources
                      process-test-resources
                      test-compile
                      process-test-classes     format-dist
                      test                     shacl-validate-target
                      prepare-package
                      package
                      pre-integration-test
                      integration-test
                      post-integration-test
                      verify
                      install                  [Profile -Pzip: release-zip]
                      deploy

                Executions with phase 'none' (invocable directly via command line, not bound to lifecycle):
                      none                     infer-and-format, infer-factorUnits, infer-scalingOf, merge-factorUnits-target, query-factorUnits, query-scalingOf, merge-scalingOf-target, reformat-sources
            -->

            <plugin>
                <groupId>org.codehaus.gmavenplus</groupId>
                <artifactId>gmavenplus-plugin</artifactId>
                <version>4.1.1</version>
                <executions>
                <!-- Ported execution: defineAdditionalProperties -->
                <execution>
                    <id>defineAdditionalProperties</id>
                    <phase>validate</phase>
                    <goals>
                        <goal>execute</goal>
                    </goals>
                    <configuration>
                        <scripts>
                            <script><![CDATA[
                                    import java.time.OffsetDateTime
                                    import java.time.format.DateTimeFormatter
                                    import java.time.temporal.ChronoField

                                    def majorMinorVersion = "${project.version}".replaceAll('^(\\w+\\.\\w+).*\$', '\$1')
                                    project.properties.setProperty('project.version.majorminor', majorMinorVersion)
                                    project.properties.setProperty('qudt.versioned.iri.prefix', "http://qudt.org/${majorMinorVersion}/")
                                    def now = OffsetDateTime.now().with(ChronoField.MILLI_OF_SECOND, 0)
                                    project.properties.setProperty('qudt.build.date', "${now}")
                                    def currentMonth = now.format(DateTimeFormatter.ofPattern("MM"))
                                    def currentYear = now.format(DateTimeFormatter.ofPattern("YYYY"))
                                    project.properties.setProperty('qudt.current.month', currentMonth)
                                    project.properties.setProperty('qudt.current.year', currentYear)
                                ]]></script>
                        </scripts>
                    </configuration>
                </execution>
                <!-- New execution: preprocess-shacl-files -->
                <execution>
                    <id>preprocess-shacl-files</id>
                    <phase>validate</phase>
                    <goals>
                        <goal>execute</goal>
                    </goals>
                    <configuration>
                        <scripts>
                            <script><![CDATA[
                                // Define base directories
                                def basedir = project.basedir.toString()
                                def srcgenDir = new File(basedir, "src/build/srcgen")
                                def targetDir = new File(basedir, "target/srcgen")

                                // Validate source directory
                                if (!srcgenDir.exists() || !srcgenDir.isDirectory()) {
                                    throw new Exception("Source generation directory not found: ${srcgenDir}")
                                }

                                // Ensure target directory exists
                                targetDir.mkdirs()

                                // Step 1: Collect all aspect directories and their file status
                                def allAspectDirs = srcgenDir.listFiles().findAll { it.isDirectory() }
                                def validAspectDirs = []
                                // Map to store omitted dirs and missing files
                                def omittedAspectDirsWithReasons = [:]

                                allAspectDirs.each { dir ->
                                    def aspectName = dir.name
                                    def queryFile = new File(dir, "query.rq")
                                    def inferTemplateFile = new File(dir, "infer-template.ttl")
                                    def validateTemplateFile = new File(dir, "validate-template.ttl")

                                    def requiredFiles = [
                                        queryFile: queryFile,
                                        inferTemplateFile: inferTemplateFile,
                                        validateTemplateFile: validateTemplateFile
                                    ]

                                    // Find missing files for this directory
                                    def missingFiles = requiredFiles.findAll { !it.value.exists() }.keySet()

                                    if (missingFiles.isEmpty()) {
                                        // All files present, add to valid list
                                        validAspectDirs << dir // Record missing files } else { omittedAspectDirsWithReasons[dir] = missingFiles
                                         }
                                }

                                // Step 2: Process valid directories
                                validAspectDirs.each { aspectDir ->
                                    def aspectName = aspectDir.name
                                    println "Processing aspect: ${aspectName}"

                                    // Load required files
                                    def queryFile = new File(aspectDir, "query.rq")
                                    def inferTemplateFile = new File(aspectDir, "infer-template.ttl")
                                    def validateTemplateFile = new File(aspectDir, "validate-template.ttl")

                                    // Process query file (e.g., remove prefixes)
                                    def queryText = queryFile.text
                                    def queryWithoutPrefixes = queryText.replaceAll('(?is)^\\s*(PREFIX\\s+[^\\n]*\\n)*\\s*', '')
                                                                .replaceAll('(?is)\\s*$', '')
                                    if (!queryWithoutPrefixes) {
                                        throw new Exception("No query body found in ${queryFile}")
                                    }
                                    queryWithoutPrefixes = queryWithoutPrefixes.replaceAll("\\\\", "\\\\\\\\")

                                    // Create output directory for this aspect
                                    def aspectOutputDir = new File(targetDir, aspectName)
                                    aspectOutputDir.mkdirs()

                                    // Define templates to process
                                    def templates = [
                                        [source: inferTemplateFile, target: "infer.ttl"],
                                        [source: validateTemplateFile, target: "validate.ttl"]
                                    ]

                                    // Generate output files
                                    templates.each { template ->
                                        def content = template.source.text
                                        def outputContent = content.replace('{{QUERY_WITHOUT_PREFIXES}}', queryWithoutPrefixes)
                                        outputContent = outputContent.replace('{{AUTOGENERATED_WARNING_DO_NOT_EDIT}}',
                                            " Auto-generated file - ALL EDITS WILL BE LOST! Edit the '-template.ttl' file instead!")
                                        def outputFile = new File(aspectOutputDir, template.target)
                                        outputFile.text = outputContent
                                        println "Generated: ${outputFile}"
                                    }
                                }

                                // Step 3: Log omitted directories with missing file details
                                if (omittedAspectDirsWithReasons) {
                                    println "The following aspects were omitted due to missing required files:"
                                    // Simplify to file names
                                    omittedAspectDirsWithReasons.each { dir, missingFiles ->
                                        def missingFileNames = missingFiles.collect { it.toString().replaceAll('^.*\\.', '') }
                                        println " - ${dir.name}: Missing ${missingFileNames.join(', ')}"
                                    }
                                } else {
                                    println "All aspects processed successfully; no missing files detected."
                                }
                            ]]>
                                </script>
                            </scripts>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.apache.groovy</groupId>
                        <artifactId>groovy-ant</artifactId>
                        <version>4.0.23</version>
                        <scope>runtime</scope>
                    </dependency>
                </dependencies>
            </plugin>

            <plugin>
                <groupId>io.github.qudtlib</groupId>
                <artifactId>shacl-maven-plugin</artifactId>
                <version>1.0.5</version>
                <executions>

                    <execution>
                        <!--
                        SHACL-validates the union of all ttl files in src/vocab and the No-OWL schema
                        against the union of QA-Tests and No-OWL schema
                        writes the validation report target/validation/validationReportSrc.ttl
                        -->
                        <id>shacl-validate-src</id>
                        <phase>process-sources</phase>
                        <goals>
                            <goal>validate</goal>
                        </goals>
                        <configuration>
                            <validations>
                                <validation>
                                    <message>Validating the QUDT sources</message>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>
                                            src/main/rdf/validation/QUDT_SRC_QA_TESTS.ttl
                                        </include>
                                    </shapes>
                                    <data>
                                        <include>
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            src/main/rdf/vocab/**/*.ttl
                                            src/main/rdf/examples/EXAMPLES_QUDT-DATATYPES.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReportSrc.ttl</outputFile>
                                </validation>
                            </validations>
                        </configuration>
                    </execution>
                    <execution>
                        <!--
                        SHACL-validates the union of all ttl files in dist/vocab and the No-OWL schema
                        against the union of QA-Tests and No-OWL schema
                        writes the validation report target/validation/validationReport.ttl
                        -->
                        <id>shacl-validate-target</id>
                        <phase>test</phase>
                        <goals>
                            <goal>validate</goal>
                        </goals>
                        <configuration>
                            <validations>
                                <validation>
                                    <message>Validating QUDT conversionMultiplier</message>
                                    <failureMessage>Problems found</failureMessage>
                                    <shapes>
                                        <include>
                                            target/srcgen/conversionMultiplier/validate.ttl
                                            src/main/rdf/validation/qudt-shacl-functions.ttl
                                        </include>
                                    </shapes>
                                    <data>
                                        <include>
                                            target/dist/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl
                                            target/dist/vocab/prefixes/VOCAB_QUDT-PREFIXES.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReport-conversionMultiplier.ttl</outputFile>
                                </validation>
                                <validation>
                                    <message>Validating QUDT build output (target/dist/)</message>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>
                                            src/main/rdf/validation/COLLECTION_QUDT_QA_TESTS_ALL.ttl
                                            src/main/rdf/validation/COLLECTION_QUDT_USER_TESTS.ttl
                                            src/main/rdf/validation/qudt-shacl-functions.ttl
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT-DATATYPES_NoOWL.ttl
                                        </include>
                                    </shapes>
                                    <data>
                                        <include>
                                            target/dist/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            target/dist/vocab/**/*.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReport.ttl</outputFile>
                                </validation>
                                <validation>
                                    <message>Validating QUDT factor units</message>
                                    <failureMessage>Problems found</failureMessage>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>
                                            src/main/rdf/validation/qudt-shacl-functions.ttl
                                            target/srcgen/factorUnits/validate.ttl
                                        </include>
                                    </shapes>
                                    <data>
                                        <include>
                                            target/dist/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReport-factorUnits.ttl</outputFile>
                                </validation>
                                <validation>
                                    <message>Validating QUDT scalingOf</message>
                                    <failureMessage>Problems found</failureMessage>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>
                                            src/main/rdf/validation/qudt-shacl-functions.ttl
                                            target/srcgen/scalingOf/validate.ttl
                                        </include>
                                    </shapes>
                                    <data>
                                        <include>
                                            target/dist/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReport-scalingOf.ttl</outputFile>
                                </validation>
                            </validations>
                        </configuration>
                    </execution>
                    <execution>
                        <!--
                        SHACL-that the SHACL definition conform to SHACL
                        writes the validation report target/validation/validationReportShacl.ttl
                        -->
                        <id>validate-shacl-files</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>validate</goal>
                        </goals>
                        <configuration>
                            <validations>
                                <validation>
                                    <message>Validating QUDT SHACL files</message>
                                    <!--skip>true</skip-->
                                    <shapes>
                                        <include>src/build/validation/SHACL-SHACL.ttl</include>
                                    </shapes>
                                    <data>
                                        <include>
                                            src/main/rdf/validation/COLLECTION_QUDT_QA_TESTS_ALL.ttl
                                            src/main/rdf/validation/COLLECTION_QUDT_USER_TESTS.ttl
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            src/main/rdf/schema/shacl/SCHEMA_QUDT-DATATYPE_NoOWL.ttl
                                        </include>
                                    </data>
                                    <outputFile>target/validation/validationReportShacl.ttl</outputFile>
                                </validation>
                            </validations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>io.github.qudtlib</groupId>
                <artifactId>rdfio-maven-plugin</artifactId>
                <version>1.4.3</version>
                <executions>
                    <execution>
                        <!--
                        makes one big file in target, after the mainPipeline has modified target files
                        -->
                        <id>all-in-one</id>
                        <phase>process-test-sources</phase>
                        <goals>
                            <goal>make</goal>
                        </goals>
                        <configuration>
                            <products>
                                <singleFile>
                                    <input>
                                        <include>
                                            src/build/srcgen/collections/SHACL-Collection.ttl
                                            target/dist/vocab/**/*.ttl
                                            target/dist/schema/shacl/SCHEMA_QUDT_NoOWL.ttl
                                            target/dist/schema/shacl/SCHEMA_QUDT-DATATYPES_NoOWL.ttl
                                            target/dist/validation/COLLECTION_QUDT_USER_TESTS.ttl
                                        </include>
                                    </input>
                                    <filters>
                                        <sparqlUpdate>
                                            <![CDATA[
                                            DELETE {
                                                ?ontology ?p ?o .
                                                ?graphMetadata ?gp ?go
                                            } WHERE {
                                                ?ontology
                                                    a owl:Ontology ;
                                                    ?p ?o .
                                                OPTIONAL {
                                                    ?ontology vaem:hasGraphMetadata ?graphMetadata .
                                                    ?graphMetadata ?gp ?go .
                                                }
                                                FILTER(! REGEX(STR(?ontology), "^.+/shacl/qudt-all$"))
                                            }
                                            ]]>
                                        </sparqlUpdate>
                                    </filters>
                                    <outputFile>target/dist/QUDT-all-in-one-SHACL.ttl</outputFile>
                                </singleFile>
                                <singleFile>
                                    <input>
                                        <include>
                                            src/build/srcgen/collections/OWL-Collection.ttl
                                            target/dist/vocab/**/*.ttl
                                            target/dist/schema/SCHEMA_QUDT.ttl
                                        </include>
                                    </input>
                                    <filters>
                                        <sparqlUpdate>
                                            <![CDATA[
                                            DELETE {
                                                ?ontology ?p ?o .
                                                ?graphMetadata ?gp ?go
                                            } WHERE {
                                                ?ontology
                                                    a owl:Ontology ;
                                                    ?p ?o .
                                                OPTIONAL {
                                                    ?ontology vaem:hasGraphMetadata ?graphMetadata .
                                                    ?graphMetadata ?gp ?go .
                                                }
                                                FILTER(! REGEX(STR(?ontology), "^.+/qudt-all$"))
                                            }
                                            ]]>
                                        </sparqlUpdate>
                                    </filters>
                                    <outputFile>target/dist/QUDT-all-in-one-OWL.ttl</outputFile>
                                </singleFile>
                            </products>
                        </configuration>
                    </execution>
                    <execution>
                        <!--
                            interesting inspections,

                            run with:
                            mvn rdfio:pipeline@inspect

                            writes to target/inspection
                        -->
                        <id>inspect</id>
                        <phase>none</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                            <pipeline>
                                <id>inspect</id>
                                <steps>
                                    <!-- make custom shacl functions available in inference and SPARQL-->
                                    <shaclFunctions>
                                        <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                    </shaclFunctions>
                                    <add>
                                        <!--
                                            this reads each file in target into a graph named 'target:{filename}'
                                        -->
                                        <files>
                                            <include>target/dist/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>target:${name}</toGraphsPattern>
                                    </add>
                                    <sparqlQuery>
                                        <sparql>
                                            <![CDATA[
                                                SELECT ?unit ?cm ?match ?broader ?deprecated
                                                WHERE {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit a qudt:Unit .
                                                        OPTIONAL {
                                                            ?unit qudt:deprecated ?deprecated .
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:conversionMultiplier ?cm
                                                        }
                                                        OPTIONAL {
                                                            ?unit qudt:exactMatch ?match
                                                        }
                                                        OPTIONAL {
                                                            ?unit skos:broader ?broader
                                                        }
                                                        FILTER (!BOUND(?cm))
                                                        FILTER NOT EXISTS {
                                                            ?unit a qudt:CurrencyUnit
                                                        }
                                                    }
                                                } ORDER BY ?deprecated ?match ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/units-without-conversionMultiplier.txt</toFile>
                                    </sparqlQuery>

                                </steps>
                            </pipeline>
                        </configuration>
                    </execution>
                    <execution>
                        <!-- unit tests for SHACL functions -->
                        <id>unitTestPipeline</id>
                        <phase>generate-sources</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                        <pipeline>
                            <id>unitTestPipeline</id>
                            <steps>
                                <!-- make custom shacl functions available in inference and SPARQL-->
                                <shaclFunctions>
                                    <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                </shaclFunctions>
                                <add>
                                    <!-- for testing, we need units and some factor units -->
                                    <file>src/main/rdf/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl</file>
                                    <file>src/build/inference/factorUnits/predefined-factors-and-scalings.ttl</file>
                                </add>
                                <assert>
                                    <message>Test qfn:decimalToDouble()</message>
                                    <failureMessage>Unit test failed for qfn:decimalToDouble()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?value ?expectedOutput) {
                                                (0 "0.0E0"    )
                                                (1 "1.0E0")
                                                (-1 "-1.0E0")
                                                (0.0001    "1.0E-4")
                                                (10000     "1.0E4" )
                                            }
                                            BIND(STR(qfn:decimalToDouble(?value)) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:exp()</message>
                                    <failureMessage>Unit test failed for qfn:exp()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                        VALUES (?base ?exp ?expectedOutput) {
                                        (2 0          1)
                                        (0 1          0)
                                        (0 -1         0)
                                        (0 0          1)
                                        (4 -1         0.25)
                                        (2 -2         0.25)
                                        (2 -3         0.125)
                                        (3 2          9)
                                        (3 3          27)
                                        (1.2 2       1.44)
                                        }
                                        BIND(qfn:exp(?base, ?exp) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:decimalPrecision()</message>
                                    <failureMessage>Unit test failed for qfn:decimalPrecision()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                            VALUES (?input ?expectedOutput) {
                                                (0            0)
                                                (0.0          0)
                                                (1            1)
                                                (1.0          1)
                                                (-1           1)
                                                (-1.0         1)
                                                (-.1          1)
                                                (10           1)
                                                (100          1)
                                                (100.001      6)
                                                (100.000      1)
                                                (00123.456000 6)
                                                (-0.00000001  1)
                                            }
                                        BIND(qfn:decimalPrecision(?input) AS ?precision)
                                        FILTER(!BOUND(?precision) || ?precision != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:decimalRoundToPrecision()</message>
                                    <failureMessage>Unit test failed for qfn:decimalRoundToPrecision()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                            VALUES (?input ?precision ?expectedOutput) {
                                                (0            1         0.0)
                                                (0.0          1         0.0)
                                                (0.1          1         0.1)
                                                (.1           1         0.1)
                                                (1            1         1.0)
                                                (+1           1         1.0)
                                                (+1.0         1         1.0)
                                                (+.0          1         0.0)
                                                (+.1          1         0.1)
                                                (1.0          1         1.0)
                                                (-1           1        -1.0)
                                                (-1.0         1        -1.0)
                                                (-.1          1        -0.1)
                                                (10           1        10.0)
                                                (100          1       100.0)
                                                (100.001      6       100.001)
                                                (100.000      1       100.0)
                                                (00123.456000 6       123.456)
                                                (-0.00000001  1        -0.00000001)
                                                (-00123.456000 3     -123.0)
                                                (00123.456000 3       123.0)
                                                (0.000000011574074074074074074  10 0.00000001157407407)
                                                (-0.000000011574074074074074074  10 -0.00000001157407407)
                                            }
                                        BIND(qfn:decimalRoundToPrecision(?input, ?precision) AS ?rounded)
                                        FILTER(!BOUND(?rounded) || ?rounded != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <add>
                                    <file>src/main/rdf/vocab/unit/VOCAB_QUDT-UNITS-ALL.ttl</file>
                                </add>
                                <assert>
                                    <message>Test qfn:localname()</message>
                                    <failureMessage>Unit test failed for qfn:localname()</failureMessage>
                                    <sparqlSelect>
                                        SELECT *
                                        WHERE {
                                            VALUES (?input ?expectedOutput) {
                                                (xsd:int            "int")
                                                (unit:M          "M")
                                            }
                                        BIND(qfn:localname(?input) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.getDimensionExponentFromLocalname()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.getDimensionExponentFromLocalname()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVecLocalname ?dimension ?expectedOutput) {
                                                ("A0E0L1I0M0H0T0D0"  "A"  0)
                                                ("A0E0L1I0M0H3T0D0"  "L"  1)
                                                ("A0E0L1I0M0H3T0D0"  "H"  3)
                                            }
                                        BIND(qfn:dimVec.getDimensionExponentFromLocalname(?dimVecLocalname, ?dimension) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.getDimensionExponent()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.getDimensionExponent()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVec ?dimension ?expectedOutput) {
                                                (qkdv:A0E0L1I0M0H0T0D0  "A"  0)
                                                (qkdv:A0E0L1I0M0H3T0D0  "L"  1)
                                                (qkdv:A0E0L1I0M0H3T0D0  "H"  3)
                                            }
                                        BIND(qfn:dimVec.getDimensionExponent(?dimVec, ?dimension) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.pow()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.pow()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVec ?exp ?expectedOutput) {
                                                (qkdv:A0E0L1I0M0H0T0D0  1 qkdv:A0E0L1I0M0H0T0D0  )
                                                (qkdv:A0E0L1I0M0H0T0D0  2 qkdv:A0E0L2I0M0H0T0D0  )
                                                (qkdv:A0E0L1I0M0H0T0D0 -2 qkdv:A0E0L-2I0M0H0T0D0 )
                                                (qkdv:A0E0L1I0M0H0T0D0 -1 qkdv:A0E0L-1I0M0H0T0D0 )
                                            }
                                        BIND(qfn:dimVec.pow(?dimVec, ?exp) AS ?actualOutput)
                                        FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.fromLocalname()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.fromLocalname()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?dimVecLocalname ?expectedOutput) {
                                                ("A0E0L1I0M0H0T0D0" qkdv:A0E0L1I0M0H0T0D0)
                                                ("A1E0L1I0M0H0T0D0" qkdv:A1E0L1I0M0H0T0D0)
                                                ("A1E0L1I0M0H0T0D1" qkdv:A1E0L1I0M0H0T0D0)
                                                ("A0E0L0I0M0H0T0D1" qkdv:A0E0L0I0M0H0T0D1)
                                                ("A0E0L0I0M0H0T0D0" qkdv:A0E0L0I0M0H0T0D1)
                                            }
                                            BIND(qfn:dimVec.fromLocalname(?dimVecLocalname) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:dimVec.multiply()</message>
                                    <failureMessage>Unit test failed for qfn:dimVec.multiply()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?leftDimVec ?rightDimVec ?expectedOutput) {
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L0I0M0H1T0D0  qkdv:A0E0L1I0M0H1T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L0I0M1H1T0D0  qkdv:A0E0L1I0M1H1T0D0)
                                                (qkdv:A0E0L1I0M1H0T0D0 qkdv:A0E0L0I0M1H1T0D0  qkdv:A0E0L1I0M2H1T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L1I0M0H0T0D0  qkdv:A0E0L2I0M0H0T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L-3I0M0H0T0D0 qkdv:A0E0L-2I0M0H0T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L-1I0M0H0T0D0 qkdv:A0E0L0I0M0H0T0D1)
                                                (qkdv:A0E0L1I0M0H0T0D0 qkdv:A0E0L0I0M0H0T0D1  qkdv:A0E0L1I0M0H0T0D0)
                                                (qkdv:A0E0L1I0M0H0T0D0 undef                  qkdv:A0E0L1I0M0H0T0D0)
                                                (undef                 qkdv:A0E0L1I0M0H0T0D0  qkdv:A0E0L1I0M0H0T0D0)
                                                (undef                 undef                  qfn:Unbound)
                                            }
                                            BIND(qfn:dimVec.multiply(?leftDimVec, ?rightDimVec) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>
                                <assert>
                                    <message>Test qfn:unit.dimVec.calculate()</message>
                                    <failureMessage>Unit test failed for qfn:unit.dimVec.calculate()</failureMessage>
                                    <sparqlSelect>
                                        <![CDATA[
                                        SELECT *
                                        WHERE {
                                            VALUES (?unit ?expectedOutput) {
                                                (unit:J             qkdv:A0E0L2I0M1H0T-2D0  )
                                                (unit:W             qkdv:A0E0L2I0M1H0T-3D0  )
                                                (unit:IN            qkdv:A0E0L1I0M0H0T0D0  )
                                                (unit:M             qfn:Unbound )
                                            }
                                            BIND(qfn:unit.dimVec.calculate(?unit) AS ?actualOutput)
                                            FILTER(BOUND(?actualOutput) != BOUND(?expectedOutput) || ?actualOutput != ?expectedOutput)
                                        }
                                        ]]>
                                    </sparqlSelect>
                                </assert>

                            </steps>
                            </pipeline>
                        </configuration>
                    </execution>

                    <execution>
                        <id>mainPipeline</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>pipeline</goal>
                        </goals>
                        <configuration>
                            <pipeline>
                                <id>mainPipeline</id>
                                <steps>
                                    <!-- make custom shacl functions available in inference and SPARQL-->
                                    <shaclFunctions>
                                        <file>src/main/rdf/validation/qudt-shacl-functions.ttl</file>
                                    </shaclFunctions>
                                    <!-- first, handle the IEC links -->
                                    <add>
                                        <!--
                                            this reads each file in target into a graph named 'target:{filename}'
                                            in the dataset and remembers the file association (see <write> at the end)
                                        -->
                                        <files>
                                            <include>target/work/vocab/**/*.ttl</include>
                                        </files>
                                        <toGraphsPattern>target:${name}</toGraphsPattern>
                                    </add>
                                    <sparqlUpdate>
                                        <message>Adding IEC links</message>
                                        <sparql>
                                            <![CDATA[
                                            INSERT {
                                                GRAPH ?g {
                                                    ?x qudt:informativeReference ?new}
                                                }
                                            WHERE {
                                                GRAPH ?g {
                                                    ?x a ?type; qudt:iec61360Code ?irdi.
                                                    VALUES (?type ?prefix) {
                                                        (qudt:Unit         "https://cdd.iec.ch/cdd/iec62720/iec62720.nsf/Units/")
                                                        (qudt:QuantityKind "https://cdd.iec.ch/cdd/iec61987/iec61987.nsf/ListsOfUnitsAllVersions/")
                                                        (qudt:PhysicalConstant "https://cdd.iec.ch/cdd/iec61987/iec61987.nsf/ListsOfUnitsAllVersions/")
                                                    }
                                                    OPTIONAL {
                                                        ?x qudt:informativeReference ?old filter(strstarts(str(?old),"https://cdd.iec.ch"))
                                                    }
                                                    BIND(replace(replace(str(?irdi),"/","-"),"#","%23") as ?irdi_new)
                                                    BIND(strdt(concat(?prefix,?irdi_new),xsd:anyURI) as ?new)
                                                }
                                            }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <savepoint><id>01-iec-links</id></savepoint>

                                    <add> <!-- load applicableUnits shapes (rules) into <shapes:applicableUnits> because we need them twice (see below) -->
                                        <file>src/build/inference/inferApplicableUnits.ttl</file>
                                        <toGraph>shapes:applicableUnits</toGraph>
                                    </add>

                                    <shaclInfer> <!-- do the quantitykinds inference -->
                                        <message>Inferring qudt:applicableUnit triples (non-currency units)</message>
                                        <shapes>
                                            <graph>shapes:applicableUnits</graph>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>target:VOCAB_QUDT-QUANTITY-KINDS-ALL.ttl</graph>
                                            <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:applicableUnits</graph>
                                            <file>target/inferred/applicableUnits.ttl</file>
                                        </inferred>
                                    </shaclInfer>

                                    <add> <!-- add the results of the quantitykinds inference to the quantityKinds graph -->
                                        <graph>inferred:applicableUnits</graph>
                                        <toGraph>target:VOCAB_QUDT-QUANTITY-KINDS-ALL.ttl</toGraph>
                                    </add>

                                    <!-- start from here if nothing has changed in the inputs of the earlier steps -->
                                    <savepoint><id>02-applicableUnits</id></savepoint>
                                    <shaclInfer>  <!-- do the quantitykinds inference for currency units -->
                                        <message>Inferring qudt:applicableUnit triples (currency units)</message>
                                        <shapes><graph>shapes:applicableUnits</graph></shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>target:VOCAB_QUDT-UNITS-CURRENCY.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:applicableCurrencyUnits</graph>
                                            <file>target/inferred/applicableUnits-currency.ttl</file>
                                        </inferred>
                                    </shaclInfer>
                                    <add>
                                        <graph>inferred:applicableCurrencyUnits</graph>
                                        <toGraph>target:VOCAB_QUDT-UNITS-CURRENCY.ttl</toGraph>
                                    </add>

                                    <!-- start from here if nothing has changed in the inputs of the earlier steps -->
                                    <savepoint><id>03-applicableUnits-currencies</id></savepoint>

                                    <sparqlUpdate>
                                        <message>Set conversionMultiplier of 1.0 on each currency unit</message>
                                        <sparql>
                                            <![CDATA[
                                                INSERT {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?cur qudt:conversionMultiplier 1.0
                                                    }
                                                } WHERE  {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?cur a qudt:CurrencyUnit
                                                        FILTER(REGEX(qfn:localname(?cur),"CCY_\\w+"))
                                                        FILTER NOT EXISTS {
                                                            ?cur qudt:conversionMultiplier ?cm
                                                        }
                                                    }
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>

                                    <shaclInfer> <!-- do the custom OWL subset inference -->
                                        <message>Performing our custom subset of OWL inferences</message>
                                        <shapes>
                                            <file>src/build/inference/owl-subset.shapes.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:owl-subset-units</graph>
                                            <file>target/inferred/owl-subset-units.ttl</file>
                                        </inferred>
                                    </shaclInfer>

                                    <add> <!-- add the inferred triples to the units graph -->
                                        <graph>inferred:owl-subset-units</graph>
                                        <toGraph>target:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>

                                    <!-- start from here if nothing has changed in the inputs of the earlier steps -->
                                    <savepoint><id>04-owl-subset-units</id></savepoint>

                                    <add>
                                        <file>src/build/inference/factorUnits/predefined-factors-and-scalings.ttl</file>
                                        <toGraph>target:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>

                                    <shaclInfer> <!-- infer the factor units -->
                                        <message>Inferring qudt:hasFactorUnit</message>
                                        <shapes>
                                            <file>target/srcgen/factorUnits/infer.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graphs>
                                                <include>
                                                    target:VOCAB_QUDT-UNITS-ALL.ttl
                                                    target:VOCAB_QUDT-PREFIXES.ttl
                                                </include>
                                            </graphs>
                                        </data>
                                        <inferred>
                                            <graph>inferred:factorUnits</graph>
                                            <file>target/inferred/factorUnits.ttl</file>
                                        </inferred>
                                    </shaclInfer>
                                    <add>
                                        <graph>inferred:factorUnits</graph>
                                        <toGraph>target:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>
                                    <savepoint><id>05-infer-factor-units</id></savepoint>
                                    <shaclInfer>
                                        <message>Inferring qudt:scalingOf</message>
                                        <shapes>
                                            <file>target/srcgen/scalingOf/infer.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>target:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <inferred>
                                            <graph>inferred:scalingOf</graph>
                                            <file>target/inferred/scalingOf.ttl</file>
                                        </inferred>
                                    </shaclInfer>
                                    <add>
                                        <graph>inferred:scalingOf</graph>
                                        <toGraph>target:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                    </add>
                                    <savepoint><id>06.1-infer-scalingOf-with-errors</id></savepoint>
                                    <sparqlQuery>
                                        <message>Show scalings of unit:KiloGM and unit:GM</message>
                                        <sparql>
                                            <![CDATA[
                                            SELECT * where {
                                                GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit
                                                        qudt:scalingOf ?u ;
                                                        qudt:conversionMultiplier ?cm .
                                                    FILTER(?u in (unit:KiloGM, unit:GM))
                                                    OPTIONAL {
                                                        ?unit qudt:prefix ?prefix .
                                                    }
                                                    BIND("scalingOf" as ?relation)
                                                }
                                            } ORDER BY ?u ?cm ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalings-of-unitGM/before.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlUpdate>
                                        <message>Fix unit:GM/unit:KiloGM qudt:scalingOf situation</message>
                                        <sparql>
                                            <![CDATA[
                                                DELETE {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        unit:KiloGM qudt:scalingOf unit:GM
                                                    }
                                                } INSERT {
                                                   GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        unit:GM qudt:scalingOf unit:KiloGM
                                                   }
                                                } WHERE {}
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <sparqlQuery>
                                        <message>Show scalings of unit:KiloGM and unit:GM</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT * where {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit qudt:conversionMultiplier ?cm.
                                                        OPTIONAL {
                                                            ?unit qudt:prefix ?prefix .
                                                        }
                                                        {
                                                            ?unit qudt:scalingOf ?u ;
                                                            BIND("scalingOf" as ?relation)
                                                        } UNION {
                                                            ?unit qudt:hasFactorUnit/qudt:hasUnit ?u ;
                                                                  qudt:factorUnitScalar ?scalar
                                                            BIND("factorUnit" as ?relation)
                                                        }
                                                    }
                                                    FILTER (?u in (unit:KiloGM, unit:GM))
                                                } ORDER BY ?u ?cm ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalings-of-unitGM/after.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <message>Show scaled units, base units and multipliers</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT * where {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:scalingOf ?base .
                                                        ?base
                                                            qudt:conversionMultiplier ?baseCm.
                                                        OPTIONAL {
                                                            ?unit qudt:prefix ?prefix .
                                                        }
                                                    }
                                                } ORDER BY ?baseCm ?prefix ?base ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalingOf/all.txt</toFile>
                                    </sparqlQuery>
                                    <savepoint><id>06-infer-scalingOf</id></savepoint>
                                    <sparqlUpdate>
                                        <message>Copy conversionMultipliers/offsets from qudt:exactMatch|skos:broader unit where not present</message>
                                        <sparql>
                                            <![CDATA[
                                                INSERT {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:conversionMultiplierSN ?cmSN ;
                                                            qudt:conversionOffset ?co ;
                                                            qudt:conversionOffset ?coSN ;
                                                            rdfs:comment ?copyComment .
                                                    }
                                                }
                                                WHERE {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl>  {
                                                        ?unit a qudt:Unit .
                                                        FILTER NOT EXISTS {
                                                            ?unit
                                                                qudt:conversionMultiplier [] ;
                                                                qudt:conversionMultiplierSN [] ;
                                                            OPTIONAL {
                                                                ?unit
                                                                    qudt:conversionOffset [];
                                                                    qudt:conversionOffsetSN [] .
                                                            }
                                                        }
                                                        ?unit ?rel ?otherUnit .
                                                        FILTER(?rel IN (qudt:exactMatch,skos:broader))
                                                        ?otherUnit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:conversionMultiplierSN ?cmSN .
                                                        OPTIONAL {
                                                            ?otherUnit
                                                                qudt:conversionOffset ?co ;
                                                                qudt:conversionOffsetSN ?coSN .
                                                        }
                                                        BIND(CONCAT("qudt:conversionMultiplier copied from unit ", STR(?otherUnit), " via relation ", STR(?rel)) AS ?copyComment)
                                                    }
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <shaclValidate>
                                        <message>Validating qudt:hasDimensionVector (making sure none are missing that cannot be derived)</message>
                                        <shapes>
                                            <file>src/build/srcgen/dimensionVector/prerequisite.ttl</file>
                                        </shapes>
                                        <data>
                                            <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                            <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                            <graph>target:VOCAB_QUDT-PREFIXES.ttl</graph>
                                        </data>
                                        <validationReport>
                                            <graph>validation:dimensionVector-underivable.ttl</graph>
                                            <file>target/validation/dimensionVector-underivable.ttl.ttl</file>
                                        </validationReport>
                                    </shaclValidate>
                                    <until>
                                        <message>Add missing dimension vectors that can be inferred</message>
                                        <indexVar>index_dv</indexVar>
                                        <body>
                                            <shaclInfer>
                                                <message>Inferring missing qudt:dimensionVector</message>
                                                <iterateUntilStable>true</iterateUntilStable>
                                                <iterationOutputFilePattern>target/inferred/dimensionVector-${index_dv}_${index}.ttl</iterationOutputFilePattern>
                                                <shapes>
                                                    <file>target/srcgen/dimensionVector/infer.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>target:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                </data>
                                                <inferred>
                                                    <graph>inferred:dimensionVector_${index_dv}</graph>
                                                    <file>target/inferred/dimensionVector_${index_dv}.ttl</file>
                                                </inferred>
                                            </shaclInfer>
                                            <add>
                                                <graph>inferred:dimensionVector_${index_dv}</graph>
                                                <toGraph>target:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                            </add>
                                        </body>
                                        <sparqlAsk>
                                            ASK {
                                                BIND(IRI(CONCAT("inferred:dimensionVector_",STR(?index_dv))) as ?graph)
                                                FILTER NOT EXISTS {
                                                    GRAPH ?graph {
                                                        ?s ?p ?o
                                                    }
                                                }
                                            }
                                        </sparqlAsk>
                                    </until>

                                    <until>
                                        <message>Replacing invalid conversionMultipliers and missing dimension vectors iteratively until no more are found</message>
                                        <indexVar>index_cm</indexVar>
                                        <sparqlAsk>
                                            ASK {
                                                BIND(IRI(CONCAT("validation:conversionMultiplierToDelete_",STR(?index_cm))) as ?graph)
                                                GRAPH ?graph {
                                                    ?report
                                                        a               sh:ValidationReport;
                                                        sh:conforms     true;
                                                }
                                            }
                                        </sparqlAsk>
                                        <body>
                                            <shaclValidate>
                                                <message>Validating qudt:conversionMultiplier (will delete invalid ones in subsequent step)</message>
                                                <!-- we don't want to fail, we want to know the errors so we can delete triples-->
                                                <failOnSeverity>None</failOnSeverity>
                                                <shapes>
                                                    <file>target/srcgen/conversionMultiplier/validate.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>target:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                </data>
                                                <validationReport>
                                                    <graph>validation:conversionMultiplierToDelete_${index_cm}</graph>
                                                    <file>target/validation/conversionMultiplier-toDelete_${index_cm}.ttl</file>
                                                </validationReport>
                                            </shaclValidate>
                                            <sparqlUpdate>
                                                <message>Deleting invalid conversion multipliers</message>
                                                <sparql>
                                                    <![CDATA[
                                                DELETE {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit qudt:conversionMultiplier ?m .
                                                        ?unit  qudt:conversionMultiplierSN ?mSN .
                                                    }
                                                }
                                                WHERE {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        {
                                                            ?unit qudt:conversionMultiplier ?m .
                                                        } UNION {
                                                            ?unit qudt:conversionMultiplierSN ?mSN .
                                                        }
                                                    }
                                                    BIND(IRI(CONCAT("validation:conversionMultiplierToDelete_",STR(?index_cm))) as ?graph)
                                                    GRAPH ?graph {
                                                        ?res
                                                            rdf:type                      sh:ValidationResult;
                                                            sh:resultPath                 qudt:conversionMultiplier;
                                                            sh:resultSeverity             sh:Violation;
                                                            sh:value                      ?unit
                                                    }
                                                }
                                                ]]>
                                                </sparql>
                                            </sparqlUpdate>

                                            <shaclInfer>
                                                <message>Inferring qudt:conversionMultiplier</message>
                                                <iterateUntilStable>true</iterateUntilStable>
                                                <iterationOutputFilePattern>target/inferred/conversionMultiplier-${index_cm}_${index}.ttl</iterationOutputFilePattern>
                                                <shapes>
                                                    <file>target/srcgen/conversionMultiplier/infer.ttl</file>
                                                </shapes>
                                                <data>
                                                    <file>target/dist/schema/SCHEMA_QUDT.ttl</file>
                                                    <graph>target:VOCAB_QUDT-UNITS-ALL.ttl</graph>
                                                    <graph>target:VOCAB_QUDT-PREFIXES.ttl</graph>
                                                </data>
                                                <inferred>
                                                    <graph>inferred:conversionMultiplier_${index_cm}</graph>
                                                    <file>target/inferred/conversionMultiplier_${index_cm}.ttl</file>
                                                </inferred>
                                            </shaclInfer>
                                            <add>
                                                <graph>inferred:conversionMultiplier_${index_cm}</graph>
                                                <toGraph>target:VOCAB_QUDT-UNITS-ALL.ttl</toGraph>
                                            </add>
                                        </body>

                                    </until>

                                    <sparqlUpdate>
                                        <message>Set conversionMultiplier to 0.0 for any unit that does not have that triple</message>
                                        <sparql>
                                            <![CDATA[
                                                INSERT {
                                                    GRAPH ?graph {
                                                        ?unit qudt:conversionMultiplier 0.0
                                                    }
                                                } WHERE {
                                                    GRAPH ?graph {
                                                        ?unit rdf:type/rdfs:subClassOf* qudt:Unit
                                                        FILTER NOT EXISTS {
                                                            ?unit qudt:conversionMultiplier ?cm
                                                        }
                                                    }
                                                    FILTER(CONTAINS(STR(?graph),"target:VOCAB"))
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>


                                    <sparqlUpdate>
                                        <message>Generate conversion multipliers in xsd:double format where it's missing</message>
                                        <sparql>
                                            <![CDATA[
                                            INSERT {
                                                GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit qudt:conversionMultiplierSN ?cmsn
                                                }
                                            }
                                            WHERE {
                                                GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                    ?unit a qudt:Unit ;
                                                          qudt:conversionMultiplier ?cm .
                                                    FILTER NOT EXISTS {
                                                        ?unit qudt:conversionMultiplierSN ?any .
                                                    }
                                                    BIND(qfn:decimalToDouble(?cm) as ?cmsn)
                                                }
                                            }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <savepoint><id>07-infer-conversionMultiplier</id></savepoint>

                                    <sparqlUpdate>
                                        <message>Limit any xsd:decimal's precision to 34</message>
                                        <sparql>
                                        DELETE {
                                            GRAPH ?g {
                                                ?s ?p ?oldVal .
                                                ?s ?pSN ?oldValSN .
                                            }
                                        }
                                        INSERT {
                                            GRAPH ?g {
                                                ?s ?p ?newVal .
                                                ?s ?pSN ?newValSN .
                                            }
                                        }
                                        WHERE {
                                           GRAPH ?g {
                                                ?s ?p ?oldVal .
                                                FILTER (DATATYPE(?oldVal) = xsd:decimal)
                                                FILTER(qfn:decimalPrecision(?oldVal) &gt; 34)
                                                BIND(IRI(CONCAT(STR(?p),"SN")) as ?pSN)
                                                BIND(qfn:decimalRoundToPrecision(?oldVal, 34) AS ?newVal)
                                                BIND(qfn:decimalToDouble(?newVal) AS ?newValSN)
                                                OPTIONAL {
                                                    ?s ?pSN ?oldValSN .
                                                }
                                           }
                                        }
                                        </sparql>
                                    </sparqlUpdate>

                                    <sparqlQuery>
                                        <message>Show non-base units that are neither scaled nor factored</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT distinct ?unit ?possibleBase ?desc ?dv ?cm where {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            a qudt:Unit ;
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:hasDimensionVector ?dv .

                                                            OPTIONAL {
                                                                ?unit qudt:plainTextDescription ?desc.
                                                            }
                                                            OPTIONAL {
                                                                    ?possibleBase
                                                                        qudt:hasDimensionVector ?dv ;
                                                                        qudt:conversionMultiplier 1.0 .
                                                            }
                                                            OPTIONAL {
                                                                {
                                                                    ?unit qudt:plainTextDescription ?desc .
                                                                } UNION {
                                                                    ?unit  dcterms:description ?desc .
                                                                }
                                                            }
                                                        FILTER (?cm != 1.0 && ?cm != 0.0)
                                                        FILTER NOT EXISTS {
                                                            {
                                                                ?unit qudt:scalingOf ?base .
                                                            } UNION {
                                                                ?unit qudt:hasFactorUnit ?fu .
                                                            } UNION {
                                                                ?unit qudt:deprecated true .
                                                            }
                                                        }
                                                    }
                                                } ORDER BY ?dv ?cm ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalingOf/missing-bases.txt</toFile>
                                    </sparqlQuery>
                                    <sparqlQuery>
                                        <message>Show scaled units, base units and multipliers</message>
                                        <sparql>
                                            <![CDATA[
                                                SELECT * where {
                                                    GRAPH <target:VOCAB_QUDT-UNITS-ALL.ttl> {
                                                        ?unit
                                                            qudt:conversionMultiplier ?cm ;
                                                            qudt:scalingOf ?base .
                                                        ?base
                                                            qudt:conversionMultiplier ?baseCm.
                                                        OPTIONAL {
                                                            ?unit qudt:prefix ?prefix .
                                                        }
                                                    }
                                                } ORDER BY ?baseCm ?prefix ?base ?unit
                                            ]]>
                                        </sparql>
                                        <toFile>target/inspection/scalingOf/all_scalings-end-of-pipeline.txt</toFile>
                                    </sparqlQuery>

                                    <sparqlUpdate>
                                        <message>change graph-file associations from target/work to target/dist before writing</message>
                                        <sparql>
                                            <![CDATA[
                                                DELETE {
                                                    GRAPH <rdfio:pipeline:metadata> {
                                                        ?file <http://qudtlib.org/rdfio/loadsInto> ?graph .
                                                    }
                                                } INSERT {
                                                    GRAPH <rdfio:pipeline:metadata> {
                                                        ?newFile <http://qudtlib.org/rdfio/loadsInto> ?graph .
                                                    }
                                                } WHERE {
                                                    GRAPH <rdfio:pipeline:metadata> {
                                                        ?file <http://qudtlib.org/rdfio/loadsInto> ?graph .
                                                    }
                                                    BIND (IRI(REPLACE(STR(?file), "target/work", "target/dist")) AS ?newFile)
                                                }
                                            ]]>
                                        </sparql>
                                    </sparqlUpdate>
                                    <write>
                                        <graphs>
                                            <include>target:*</include>
                                        </graphs>
                                    </write>
                                    <savepoint><id>99-endOfPipeline</id></savepoint>
                                </steps>
                            </pipeline>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>com.diffplug.spotless</groupId>
                <artifactId>spotless-maven-plugin</artifactId>
                <version>2.44.0.BETA3</version>
                <configuration>
                        <!-- default configuration - this is the one that is used if the plugin is
                        invoked directly using `mvn spotless:apply` or `mvn spotless:check`
                        -->
                        <rdf>
                            <includes>
                                <include>src/main/rdf/**/*.ttl</include>
                                <include>src/build/**/*.ttl</include>
                                <include>target/**/*.ttl</include>
                            </includes>
                            <excludes>
                                <exclude>target/inferred/</exclude>
                                <exclude>target/validation/</exclude>
                            </excludes>
                            <format>
                                <failOnWarning>false</failOnWarning>
                                <verify>true</verify>
                                <turtleFormatterVersion>1.2.14</turtleFormatterVersion>
                                <turtle>
                                    <predicateOrder>rdf:type,owl:imports</predicateOrder>
                                    <firstPredicateInNewLine>true</firstPredicateInNewLine>
                                </turtle>
                            </format>
                        </rdf>
                    <markdown>
                        <includes>
                            <include>**/*.md</include>
                        </includes>
                        <flexmark />
                    </markdown>

                    <formats>
                        <!--
                        does our placeholder replacements using the maven properties
                        that were set using the groovy plugin
                        -->
                        <format>
                            <includes>
                                <include>target/dist/**/*.*</include>
                                <include>target/build/**/*.*</include>
                            </includes>
                            <excludes>
                                <include>target/**/*.xlsx</include>
                                <include>target/**/*.xls</include>
                                <include>target/**/*.gif</include>
                                <include>target/**/*.zip</include>
                                <include>target/**/*.pdf</include>
                                <include>target/**/*.ppt</include>
                                <include>target/**/*.pptx</include>
                            </excludes>
                            <replaceRegex>
                                <name>full version replacement</name>
                                <searchRegex>\$\$QUDT_VERSION\$\$</searchRegex>
                                <replacement>${project.version}</replacement>
                            </replaceRegex>
                            <replaceRegex>
                                <name>major.minor version replacement</name>
                                <searchRegex>\$\$QUDT_MAJOR_MINOR_VERSION\$\$</searchRegex>
                                <replacement>${project.version.majorminor}</replacement>
                            </replaceRegex>
                            <replace>
                                <name>publish date replacement</name>
                                <search>1234-12-12T12:34:56Z</search>
                                <replacement>${qudt.build.date}</replacement>
                            </replace>
                            <replaceRegex>
                                <name>versioned IRI replacement</name>
                                <searchRegex>http://qudt.org/\d+.\d+/</searchRegex>
                                <replacement>${qudt.versioned.iri.prefix}</replacement>
                            </replaceRegex>
                            <replace>
                                <name>current year</name>
                                <search>$$$$CURRENT_YEAR$$$$</search>
                                <replacement>${qudt.current.year}</replacement>
                            </replace>
                            <replace>
                                <name>current month</name>
                                <search>$$$$CURRENT_MONTH$$$$</search>
                                <replacement>${qudt.current.month}</replacement>
                            </replace>
                            <replace>
                                <name>current year</name>
                                <search>$$$$QUDT_PREV_RELEASE_YEAR$$$$</search>
                                <replacement>${qudtPrevReleaseYear}</replacement>
                            </replace>
                            <replace>
                                <name>current month</name>
                                <search>$$$$QUDT_PREV_RELEASE_MONTH$$$$</search>
                                <replacement>${qudtPrevReleaseMonth}</replacement>
                            </replace>
                        </format>
                    </formats>

                </configuration>
                <executions>
                    <execution>
                        <!--
                            checks formats in all files we care about before anything else
                            happens in the build.

                            Note: The more comfortable alternative would be to
                            start with formatting everything, but we cannot do it: it would allow
                            for a commit to contain non-formatted files. Those files would be formatted
                            during the server-side build but not updated in the repo. A subsequent
                            merge/rebase to our main branch would lead to having unformatted files in
                            the main branch.
                        -->
                        <id>check-source-format</id>
                        <phase>process-sources</phase>
                        <goals>
                            <goal>check</goal>
                        </goals>
                        <configuration>
                            <formats>
                            <!--
                            does our placeholder replacements using the maven properties
                            that were set using the groovy plugin
                            -->
                                <format>
                                    <excludes>
                                        <exclude>target/**/*.*</exclude>
                                    </excludes>
                                </format>
                            </formats>

                            <rdf>
                                <includes>
                                    <include>src/**/*.ttl</include>
                                </includes>
                                <excludes>
                                    <exclude>target/**/*.*</exclude>
                                    <exclude>src/build/srcgen/**/infer.ttl</exclude>
                                    <exclude>src/build/srcgen/**/validate.ttl</exclude>
                                </excludes>
                            </rdf>
                        </configuration>
                    </execution>
                    <execution>
                        <!-- formats source files that were generated during the build up to the compile phase -->
                        <id>reformat-sources</id>
                        <phase>none</phase>
                        <goals>
                            <goal>apply</goal>
                        </goals>
                        <configuration>
                            <upToDateChecking>
                                <enabled>false</enabled>
                            </upToDateChecking>
                            <rdf>
                                <!-- redefine includes so we only format the sources that are allowed to change -->
                                <includes>
                                    <include>src/main/rdf/**/*.ttl</include>
                                </includes>
                            </rdf>
                        </configuration>
                    </execution>
                    <execution>
                        <!-- formats everything in the target/dist folder so we have a clean set of distribution files-->
                        <id>format-dist</id>
                        <phase>process-test-classes</phase>
                        <goals>
                            <goal>apply</goal>
                        </goals>
                        <configuration>
                            <upToDateChecking>
                                <enabled>false</enabled>
                            </upToDateChecking>
                            <rdf>
                                <!-- redefine rdf includes to only include target/dist -->
                                <includes>
                                    <include>target/**/*.ttl</include>
                                </includes>
                                <excludes>
                                    <exclude>target/validation/*.ttl</exclude>
                                    <exclude>target/inferred/*.ttl</exclude>
                                </excludes>
                            </rdf>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <artifactId>maven-resources-plugin</artifactId>
                <version>3.3.1</version>
                <!-- copies all required files from src or root dir to the target folder -->
                <executions>
                    <execution>
                        <id>copy-rdf-to-dist</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/dist</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/rdf</directory>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                    <execution>
                        <id>copy-rdf-to-work</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/work</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/rdf</directory>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                    <execution>
                        <id>copy-docs</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/dist/docs</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/docs</directory>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                    <execution>
                        <id>copy-root-files</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/dist</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>${project.basedir}</directory>
                                    <includes>
                                        <include>*.md</include>
                                    </includes>
                                    <excludes>
                                        <exclude>BUILDING.md</exclude>
                                    </excludes>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-install-plugin</artifactId>
                <version>3.1.2</version>
                <!--
                we want to suppress this plugin, which makes no sense unless we want to
                allow people to use qudt as a maven dependency
                -->
                <executions>
                    <execution>
                        <phase>none</phase>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-deploy-plugin</artifactId>
                <version>3.1.2</version>
                <!--
                we want to suppress this plugin, which makes no sense unless we want to
                allow people to use qudt as a maven dependency AND we want to publish it
                to a maven registry
                -->
                <configuration>
                    <!-- we never want to deploy, our github actions take care of that -->
                    <skip>true</skip>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <profiles>
        <!--
            profiles are activated using the -P[profileName] command line arg to the mvn command
            if activated, the structure contained in the <profile> element is merged with the pom structure.
        -->
        <profile>
            <!-- profile that causes the zip file to be created -->
            <id>zip</id>
            <build>
                <plugins>
                    <plugin>
                        <artifactId>maven-assembly-plugin</artifactId>
                        <configuration>
                            <descriptors>
                                <descriptor>src/build/assembly/releaseZip.xml</descriptor>
                            </descriptors>
                            <finalName>${project.name}-${project.version}</finalName>
                            <appendAssemblyId>false</appendAssemblyId>
                        </configuration>
                        <executions>
                            <execution>
                                <id>release-zip</id>
                                <goals>
                                    <goal>single</goal>
                                </goals>
                                <phase>install</phase>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <!--
                runs all source modifications (inferences and formatting) before anything else in the build
             -->
            <id>fix</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>com.diffplug.spotless</groupId>
                        <artifactId>spotless-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>reformat-sources</id>
                                <phase>validate</phase>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>